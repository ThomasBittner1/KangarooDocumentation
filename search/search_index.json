{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"","text":"<p>Kangaroo-Builder is a tool for creating Rigs. It\u2019s a complete system that includes:</p> <ul> <li>Body Rig Builder  </li> <li>Face Rig Builder </li> <li>Pose Editor</li> <li>Skinning, WeightMaps and Geometry tools   </li> <li>Pipeline for collaborating/sharing within the Team and creating Backups  </li> </ul> <p></p> \"I worked over 15 years for well known companies around the world that all had their own rigging systems. Each of them had a few pros and lots of cons. My big dream over these years was to create the one ultimate rigging system that just works properly so that companies won\u2019t have to keep reinventing the wheel again and again. Kangaroo-Builder is the result of that.\"   Thomas Bittner, Author of Kangaroo-Builder  <p></p>"},{"location":"FAQ/","title":"FAQ","text":""},{"location":"FAQ/#which-maya-versions-are-supported","title":"Which Maya versions are supported?","text":"<ul> <li>Maya 2022 (Windows)</li> <li>Maya 2023 (Windows, Linux)</li> <li>Maya 2024 (Windows, Linux)</li> <li>Maya 2025 (Windows, Linux)</li> </ul>"},{"location":"FAQ/#does-it-work-in-linux-or-mac","title":"Does it work in Linux or Mac?","text":"<p>The latest version 5 does support all three systems</p>"},{"location":"FAQ/#after-building-the-character-some-vertices-are-stretched-to-the-origin","title":"After building the character, some vertices are stretched to the origin","text":"<p>Most likely this is because the loadDeformer() function is skinning some influences that don\u2019t exist in the rig anymore. If those influences don\u2019t exist in the rig, the loadDeformer() function will create them as simple joints outside the hierarchy. To debug that, either just run until loadDeformer or Run All with the clean function turned off. Then look at joints outside the hierarchy. Easiest way to fix the weights of those is with the move skinCluster tool</p>"},{"location":"FAQ/#maya-crashes-very-often","title":"Maya crashes very often","text":"<p>Make sure you are in DG mode at the time you open Maya: Windows -&gt; Settings -&gt; Preferences -&gt; Animation -&gt; switch to DG at the very top. Then restart Maya and verify that it\u2019s still on DG.   This is not just for Kangaroo. Generally Rigging should be done in DG while parallel and GPU is for Animating.</p>"},{"location":"FAQ/#when-i-use-studio-library-on-kangaroo-rigs-it-breaks-on-saving-animation-and-creates-some-transforms-called-curve1-curve2","title":"When I use Studio Library on Kangaroo Rigs, it breaks on saving Animation, and creates some transforms called CURVE1, CURVE2,..","text":"<p>First try to get the latest version. of Studio Library. Older versions didn't get along with joint controls, and on Kangaroo rigs the  hand/foot iks are joints.  To go around that problem, go into the studio library code. Find the file animation.py \u2013 and change the line (probably on Line 567) <pre><code>if maya.cmds.nodeType(node_path) == \u201ctransform\u201d:\n</code></pre> to <pre><code>if maya.cmds.nodeType(node_path) in [\u201ctransform\u201d, \u201cjoint\u201d]:\n</code></pre></p>"},{"location":"contact/","title":"Contact","text":"<p>Please keep in mind this is new beta documentation of Version 5 that is not published yet.</p> <p>The current website (Version 4) is www.kangaroo-builder.com </p> <p>Contact us.</p>"},{"location":"download/","title":"Download","text":"<p>Download of Kangaroo Version 4 is not available yet.</p> <p>In the meantime, please download from www.kangaroo-builder.com </p> <p>For more info - contact</p>"},{"location":"gameEngines/","title":"GAMESKELETON","text":"<p>Game Engines usually just want a very simple rig that has only joints and skinCluster. To get that, turn on the function create_GAMESKELETON() After you run that function, you'll see a GAMESKELETON group that you can export as an FBX.  You can even use the function button export FBX to do that for you.</p>"},{"location":"gameEngines/#unrealengine-biped","title":"UnrealEngine Biped","text":"<p>If you want the Biped Rig from Unreal Engine, just turn on bMetahumanJoints in the buildPuppet() function. It'll use this rig for doing the GAMESKELETON later:    Later when you import that character to UnrealEngine, it'll give you a lot of things for free. For example you could just create the Biped Control Rig without much effort.</p>"},{"location":"gameEngines/#limitations","title":"Limitations","text":"<p>In the usual case Game Engines just want simple blendShapes and skinCluster. That means most of the face tools  don't work in the Game Engine the same way as in Maya. So when you setup the face, best only stick with blendShapes.</p> <p>There's a few setups that can get converted to blendShapes. It's still lower quality and can end up with a ton of blendShapes. But in situations where you are creating cinematics or movies and you are using UnrealEngine just as a Render Tool, those blendShape convertions might just be the right thing.   </p>"},{"location":"gameEngines/#zipper","title":"Zipper","text":"<p>If you create postZipper(), you can run the function blendShapifyPostZipper(), and that'll bake the setup into  a lot of blendShapes.</p>"},{"location":"gameEngines/#tweakers","title":"Tweakers","text":"<p>If you used the TWEAKER_lips() (without bSpline), TWEAKER_lids() or TWEAKER_simpleBrows(), you can get those baked with the blendShapifyTweakers() function </p>"},{"location":"gameEngines/#building-control-rigs","title":"Building Control Rigs","text":"<p>In older versions of Kangaroo there was a Control Rig Builder. Unfortunately that is no more in Kangaroo Version 5 due to lack of funding.   If you are curious about what was there and might (!) come back in future, feel free to watch this video:  </p>"},{"location":"installation/","title":"Getting Started","text":""},{"location":"installation/#installation","title":"Installation","text":"<ol> <li>Extract the zip file, and copy the content somewhere on disk.</li> <li>Drag&amp;Drop the install.mel file into Maya Scene View</li> <li>You should see the new KangarooBuilder shelf already.</li> <li>Restart Maya</li> </ol> <p>If you get an error that numpy is missing, you'll have to install numpy, too. We do that with pip install. Do the following thing in a Command Prompt (cmd). You'll most likely have to change the path on maya version or installation location.</p> <pre><code>cd C:\\Program Files\\Autodesk\\Maya2024\\bin \nmayapy.exe -m pip install \u2010\u2010user numpy\n</code></pre> <p>Note</p> <p>If you get weird looking errors, try without the --user numpy flag</p> <p>If you just want to use the skinCluster/geometry tools or the shape editor - you are done at this point.</p>"},{"location":"installation/#the-directories","title":"The Directories","text":"<p>First of all you need to understand that Kangaroo is not just a Rigging Tool. It's a Rigging Pipeline that helps you also increment/version your assets, and even backup and share with the team.   If you work in a studio where they have their own studio pipeline, then Kangaroo is still another pipeline that runs parallel to the studio pipeline. You can set things up to connect to the studio pipeline at two points:</p> <ol> <li>grabbing the model from studio pipeline, and later</li> <li>publishing the actual rig into the studio pipeline</li> </ol> <p>But how to do that is explained in Python - Connecting to Studio Pipeline</p>"},{"location":"installation/#assetslocal","title":"AssetsLocal","text":"<p>First we need to create the AssetsLocal folder. It's the folder where you'll work.  It can be anywhere on your disk drive and doesn't necessarily have to be shared with others.  Just create an empty folder, and specify that in the settings:   </p> <p>After changing the settings, Restart Maya.</p> <p>Then inside that new folder, let's create another empty folder for your project, and name it __MYPROJECT__ It's important that there are 2 underscores before the name, and 2 underscores after the name.  And all has to be UPPERCASE. Without following those rules, Kangaroo won't recognize the folder as a project.</p> <p>Note</p> <p>You could also specify the assestLocal path with the Environment Variable KANGAROO_WORK_PATH. This can be  useful if you are setting up kangaroo for a bigger rigging department</p>"},{"location":"installation/#templates","title":"Templates","text":"<p>To start creating characters, 99.95 % of the times you copy from an existing one and adjust. And we usually grab one from the server. Templates is one server that comes with the tool, and has those assets:</p> <ul> <li>BASEHUMAN</li> <li>BASEDOG (digigrade quadruped - dogs, cats, ...)</li> <li>BASEHORSE (unguligrade quadruped - horses, deers, ..)</li> <li>BASEMOUSE (plantigrade quadruped - mouse, bears, ...)</li> <li>BASEBIRD</li> <li>BASEPROP</li> <li>BASELEGOFIGURE</li> <li>THOMAS (BlendShape driven Face Rig)</li> </ul> <p> Let's go to the BASEHUMAN for example, and then in Export -&gt; NEW, set the project and new asset name, and then click Create  By default it's doing UPPERCASE. It's recommended that you keep it this way since mixed casing can get uncomfortable in one out of 100 cases. Just imagine two people create the same asset name but different casings ;-) But if you need to match the name from a studio pipeline, you have the option to do the dangerous mixed cases name </p>"},{"location":"installation/#assetsserver","title":"AssetsServer","text":"<p>At this point you could theoretically jump to the next tutorial and just start building chaeracters. But you have to setup the server at some point anyway, why not do it now.</p> <p>You need a server location where you publish the characters to. And that is for one or two things:</p> <ol> <li>Backup your work </li> <li>Sharing with the rigging team</li> </ol> <p>The new server should be on another disk, that could be a folder setup-ed with Smartdrive from Dropbox, Box or GoogleDrive. The most stable with previous tests has been Dropbox. Or if you are working in a network, it can be a location on the network. </p> <p>If you don't have one yet, just create an empty folder again. And after that, open the pathEnv.mel file with a text editor, and change the path after default@ to be your server path. Important: even in Windows, do not use \\ for separating the folders, it all has to be /. If you copy/paste path in Windows, it'll do the wrong one and you'll have to fix that. <pre><code>putenv \"KANGAROO_SERVER_PATH\" \"templates@./templates; default@C:/Users/thoma/Dropbox/assetsServer\";\n</code></pre> See how there's the template server before? Yes, you remember it correctly, the template place where we copied character from before is another server!</p> <p>Also - the pathEnv.mel is basically setting the Environment variable. If you are a Pipeline TD you might say this is dirty and messy. But no, this is just a simple way to get you started quickly. If you want to set the Environment Variables in a different way, just comment out those lines with //, and create the Environment variables wherever you prefer. There's even another file example__Maya.env where you can see how you would set it up in the usual way</p>"},{"location":"installation/#roadmap-for-first-character","title":"Roadmap for First Character","text":"<p>Once you've setup-ed your directories and started the character with the create NEW tool, you can start actually  rig the character with the points below. </p> <p>Always keep in mind that Kangaroo is a procedural tool where we don't  just work on a maya file and send that out when we are done. Instead we work on the data that in the end creates the character with the RunAll button.</p> <p>And generally don't get carried away with one file for too long. Always just export and rebuild. And best regularly publish your character so you can track things back easier whenever something's not working.</p> <ol> <li>Specify Your Model</li> <li>Place Blueprint Joints</li> <li>Skin the Character, and export weights</li> <li>Shape the Ctrls, and export them</li> <li>When you click RunAll in the builder, you have your Rig.  </li> </ol> <p>Success</p> <p>Congratulations! You finished your first Character :-) </p> <p>Keep in mind if you got until here, it means you still just scratched the surface of what you can do with Kangaroo.  Best keep reading the documentation and see how you can improve your rig with what you've learend.</p>"},{"location":"license/","title":"License","text":"<p>If you are just testing Kangaroo-Builder or using it on student or hobby projects that don't generate income - you are free to use it without license.</p> <p>For other cases, see options below. Don't find the right License for you? Contact us. </p> <p>Single Perpetual \u2013 300 USD Recommended for Freelancers or small studios with only one rigger Pay with Paypal</p> <p>3 Seats Perpetual \u2013 700 USD Recommonded for small studios Pay with Paypal</p> <p>5 Seats Perpetual - 1000 USD Pay with Paypal</p> <p>10 Seats Perpatual - 2000 USD  Pay with Paypal</p> <p>Unlimited Seats Perpetual - 5000 USD Pay with Paypal</p>"},{"location":"modelChange/","title":"Model Change","text":"<p>Kangaroo has lots of good tools for dealing with model changes. This document gives you an overview of what tools you can/should use for different situations. </p>"},{"location":"modelChange/#same-topology-different-shape","title":"Same Topology - Different shape","text":"<p>When the topology and proportions are the same, things are relatively easy.</p> <p>LoadDeformer() will load the files without issues since (by default) it's just loading by vertex order.</p> <p>But blendShapes, such as in ShapeEditor or PoseEditor need some attention.</p>"},{"location":"modelChange/#same-topology-poseeditor","title":"Same Topology - PoseEditor","text":"<p>See Pose Editor Model Update You might be able to use the blendShape option. But if not - the warp option should work just fine, too.</p>"},{"location":"modelChange/#same-topology-shape-editor-model-update","title":"Same Topology - Shape Editor model update","text":"<p>See Shape Editor Model Update</p>"},{"location":"modelChange/#same-topology-other-target-geos","title":"Same Topology - Other Target geos","text":"<p>Any other mesh you can just warp with the Geometry Tools</p>"},{"location":"modelChange/#topology-change","title":"Topology change","text":""},{"location":"modelChange/#topology-change-loaddeformers","title":"Topology change - loadDeformers()","text":"<p>In the loadDeformers() can probably handle it on its own. Check when to not use Deformer Import Tool.</p>"},{"location":"modelChange/#topology-change-poseeditor","title":"Topology change - PoseEditor","text":"<p>See Pose Editor Model Update The warp option will do the trick here. </p> <p>Note</p> <p>In some cases when meshes got split into more meshes, you may have to do a few different hacks such as using the TOOLS -&gt; wrap option </p>"},{"location":"modelChange/#topology-change-shape-editor","title":"Topology change - Shape Editor","text":"<p>This is a bit of a manual hack, but not too bad. Check here </p>"},{"location":"modelChange/#topology-change-other-target-geos","title":"Topology change - Other Target geos","text":"<p>Any other mesh you can just warp with the Geometry Tools</p>"},{"location":"modelChange/#topology-change-custom-attachers","title":"Topology change - Custom Attachers","text":"<p>Custom attacher setups in the Puppet tool should be fine in most cases. Unless you specified a vertex. More infos on Custom Attachers</p> <p>Warning</p> <p>It's easy to forget adjusting the vertex id! You'll know if later some ctrls suddenly fly around when you rotate some irrelevant ctrl. And for future consider not assigning vertex ids. They should only be done when really needed.</p>"},{"location":"modelChange/#different-mesh-names","title":"Different Mesh Names","text":""},{"location":"modelChange/#different-mesh-names-deformers","title":"Different Mesh Names - Deformers","text":"<p>If just one or two mesh names changed, check when to not use Deformer Import Tool.</p> <p>But if you have a ton of different meshes, it might be worth looking at Load Best Fitting SkinClusters</p>"},{"location":"modelChange/#different-mesh-names-custom-attachers","title":"Different Mesh Names - Custom Attachers","text":"<p>If you've used the custom attachers in the puppet tool, that's also a bit more manual setup at this point.  You could open the puppet.rig file and text/replace if you are careful.</p>"},{"location":"modelChange/#different-mesh-names-face-rig","title":"Different Mesh Names - Face Rig","text":"<p>If you have a face rig, you'll have to do more manual setup inside the build folder functions, adjusting names etc.</p> <p>Recommendation</p> <p>If you've already rigged the Face, try to push back on modeling if they want to change the mesh names! Very likely it'll be less trouble for them to keep a bad name than for you having to change name in all of the setups.</p>"},{"location":"modelChange/#different-proportions","title":"Different Proportions","text":""},{"location":"modelChange/#different-proportions-blueprints","title":"Different Proportions - Blueprints","text":"<p>For different proportions you'll need to adjust the blueprints in the puppet tool. If the topology is the same, you can use the warpXforms tool to  warp the blueprint rig to the new model.</p>"},{"location":"modelChange/#different-proportions-shape-editor","title":"Different Proportions - Shape Editor","text":"<p>If the topology is also different, it's more complex. It's like creating a new character - check Shape Editor</p>"},{"location":"modelChange/#different-proportions-face","title":"Different Proportions - Face","text":"<p>And then basically every blueprint group in the mayaImport folder needs to be warped to the new mesh.</p>"},{"location":"modelChange/#maya-import-folder","title":"Maya Import Folder","text":"<p>It's also good practise to go through all the files in the mayaImport folder and check one by one to see which needs to get updated. Especially when you've created a Face Rig, you might have a few files in there! </p>"},{"location":"modelNamingConvention/","title":"Model Naming Convention","text":"<p>Generally Kangaroo is relatively flexible when it comes to model names.</p> <p>But there are some rules, and this document lists them:</p>"},{"location":"modelNamingConvention/#no-clashing-names","title":"No clashing names","text":"<p>Having 2 meshes with the same name is bad news. Not just for Kangaroo!</p>"},{"location":"modelNamingConvention/#no-double-underscores","title":"No double underscores","text":"<p>That's because Kangaroo is using double underscores (__) in the name for something else</p>"},{"location":"modelNamingConvention/#flexible-with-leftright","title":"Flexible with left/right","text":"<p>The safest thing is putting l or r into the name, such as mesh_l_wrist. But kangaroo accepts a wide variaty of side indications.</p>"},{"location":"modelNamingConvention/#prefixessuffixes","title":"Prefixes/Suffixes","text":"<p>Prefixes or suffixes are recommended but not mandatory. It is much cleaner to have a mesh called for example mesh_l_wrist or l_wrist_geo, instead of l_wrist.   It also reduces the danger of creating clashing names by mistake.</p>"},{"location":"modelNamingConvention/#reserved-names","title":"Reserved Names","text":"<p>The following names are reserved, please don't use them for your meshes:</p> <ul> <li>master</li> <li>modules</li> <li>model</li> <li>skeleton</li> <li>ctrls</li> </ul>"},{"location":"picker/","title":"Animator Tools","text":"<p>This is an animation tool that can do stuff like:</p> <ul> <li>select ctrls</li> <li>fk2ik switch</li> <li>space switch</li> <li>mirror ctrl poses/animations</li> <li>Biped Motion Capture</li> <li>Motion Path (experimental)</li> </ul>"},{"location":"picker/#for-animators","title":"For Animators..","text":"<p>Video</p> <p>The best way to see how it works is watching the first 1min 45seconds from this video from the start.</p>"},{"location":"picker/#fk2ik-switch","title":"Fk2Ik Switch","text":"<p>Video</p> <p>Whatch it in the video from here</p> <p>Isolated Menu</p> <p>If you just want this switch without the whole UI, that's possible and you can see here how it looks.</p>"},{"location":"picker/#space-switch","title":"Space Switch","text":"<p>The space switch button can help animators to switch between spaces. </p> <p>Video</p> <p>Whatch it in the video from here</p> <p>Isolated Menu</p> <p>If you just want this switch without the whole UI, that's possible and you can see here how it looks.</p>"},{"location":"picker/#mirror","title":"Mirror","text":"<p>Video</p> <p>Watch how to mirror ctrl poses or animation here</p>"},{"location":"picker/#for-riggers","title":"For Riggers..","text":"<p>Riggers mainly need to create the elements and jpg files. Watch the video from here to see how to do that.</p>"},{"location":"picker/#custom-picker-file-location","title":"Custom Picker File Location","text":"<p>In the video we are just putting the picker files into the tool directory. While that's totally valid, sometimes you might want to put them into a different location. Use the Environment Variable KANGAROO_PICKER_PATH to specify a different path.</p>"},{"location":"picker/#more-picker-tabs-per-character","title":"More picker tabs per character","text":"<p>This feature was added recently, that's why it's not shown in the video yet. By default (as shown in the video) you just have 1 pair of files, such as: <pre><code>mainCharacter.elements\nmainCharacter.jpg\n</code></pre> But you can add an extra one, for example like this: <pre><code>mainCharacter.elements\nmainCharacter.jpg\nmainCharacter_face.elements\nmainCharacter_face.jpg\n</code></pre> And then you'll have 2 picker tabs for that character.</p>"},{"location":"picker/#isolated-menus","title":"Isolated Menus","text":"<p>Sometimes animators don't want the whole UI, but they just want some menus. Below are some python codes that you can  for example add to a shelf button. I'll then open small switch menus from those buttons.</p> <p>Switching Spaces:  To get this menu, run the python lines below: <pre><code>import kangarooAnimation.KangarooMatchTools as KangarooMatchTools; \nKangarooMatchTools.spaceSwitchMenu()\n</code></pre></p> <p>Switching between Fk and Ik:  Run those lines to get that menu: <pre><code>import kangarooAnimation.KangarooMatchTools as KangarooMatchTools; \nKangarooMatchTools.humanLimbsSwitchMenu()\n</code></pre></p>"},{"location":"picker/#tool-installation","title":"Tool Installation","text":"<p>The tool is installed by default if you've installed Kangaroo-Builder as shown in the Getting Started page (The first part is enough - no need to setup things like assetsLocal or servers). Animators can just open it from the same install that you have.  </p> <p>But in case they don't have access to it, all you need to give them is the kangarooAnimation folder.  This folder is isolated and is not linking to any other libraries.</p> <p>If animators have that folder sourced, they can open the UI with those Python lines: <pre><code>import kangarooAnimation.KangarooAnimTool as KangarooAnimTool; \nKangarooAnimTool.showUI(False)\n</code></pre> Or they can run the lines shown in Isolated Menus </p>"},{"location":"body/deformations/","title":"Muscle Joints","text":"<p>Muscle joints are simple lightweight joints that can be great for preserving volume, or some piston type parts</p>"},{"location":"body/deformations/#blend-joints","title":"Blend Joints","text":"<p>Those are simple joints that rotate a percentage of the main joints. And they have a lot of attributes to make them translate or scale based on their parents' rotation</p> <p>To add one, just specify the joint in the list. </p> <p>Then after running that function you'll get that joint. And you can adjust its values: </p> <p>Mirroring and Saving those values can be done with the DEFAULTATTRS options. </p> <p>Note</p> <p>the DEFAULTATTRS thing is a common workflow throughout all the kangaroo tools. Especially when we come to the face</p>"},{"location":"body/motionCapture/","title":"Motion Capture","text":"<p>Maya has a great tool for Motion Capture retargeting, which is called humanIK. Kangaroo is simplifying this for you. If just turn on the function humanIkSkeleton(), it'll create this skeleton:  There's nothing for you to do at this point. Just know that it'll use this later under the hood when Animators apply  Motion Capture using the Picker. For more information check: Animator Tools</p>"},{"location":"body/poseEditor1/","title":"Pose Editor I","text":"<p>Pose Editor is one of the biggest additions in Kangaroo 5.</p> <p>To open it, click the function poseEditorApply() and then the button Open Editor: </p> <p>It consists of Interpolators, Interpolator Attributes and Targets, Meshes and Ctrl Tables. </p> <p>Video</p> <p>To see how the Pose Editor works in action, you can also watch this Video.   Especially the model update (Pose Editor II) part has changed.</p>"},{"location":"body/poseEditor1/#interpolators-calculating-the-pose","title":"Interpolators - Calculating the Pose","text":"<p>Interpolators are little setups that analyze the rig to see if and how strong we are in a pose.  There's a few different types: </p> <ul> <li>signedAngle - simple rotations like elbow, knees</li> <li>cones - 3 dimensional rotations</li> <li>mayaPose - 3 dimensional rotations</li> <li>upleg - specialized for upper leg going up</li> <li>custom - attributes or for creating your own custom interpolator</li> </ul> <p>To add interpolators, just click the Add Button at the very top left of the UI. It tells you what you need to select. And the  selection order doesn't matter here. </p>"},{"location":"body/poseEditor1/#signedangle","title":"signedAngle","text":"<p>SignedAngle is the simplest one, and great for simple rotations where you can assume that animators usually just rotate it in one angle. As the right side of the menu says - Select Attribute of Ctrl and Joint: select the joint, then the ctrl and it in the Channel Box mark it like this:  Once it created it, special attention is required on the Angle Axis and Up Axis. It might be a bit confusing, because those are the ones on the joints, not the ctrl!   Angle Axis is the rotation axis of the joints that we want to measure (usually different to the CtrlAttr because it's in different space). And the Up Axis is one of the other two.  Which one? Just try it out which one is more stable in your case. But never set Angle Axis and Up Axis to  be identlical, because this will lead to troubles. </p> <p>Here's a short video how we create the singedAngle for the knee:</p>      Your browser does not support the video tag.  <p>In this video we didn't have to set the Angle Axis and Up Axis, becasue on elbows and knees the default is already correct.</p>"},{"location":"body/poseEditor1/#mayapose","title":"mayaPose","text":"<p>This is using the maya native interpolator. It interpolates between all the poses of the interpolator at  once, and normalizes them in some way that whenever you are in one pose, all the other poses are 0. That's a great thing for when you are doing upper arm or clavicle corrective poses where it's important that all the poses blend nicely with each others.  But it comes with a few disadvantages:  </p> <ul> <li>You can't adjust the timing   </li> <li>The timing can get a bit uneven between the poses (for correctives this might be fine, but could be an issue for ctrls).   </li> <li>You always need to have at least 4 poses (manageable, just add a few extra poses you don't use)  </li> <li>The math is not understandable for the most of us, so the output can sometimes be somewhat unexpected. And in some  cases when things are wrong it might even output something like INF or all poses having the same output number like 0.25.  Whenever that happens just try to align them a bit nicer and make sure that you not less than 4 poses.</li> </ul> <p>Here's a short video how we create them for the upper arm:</p>      Your browser does not support the video tag."},{"location":"body/poseEditor1/#cone","title":"Cone","text":"<p>Cones just measure how small the angle is between joint and the cone. </p> <p>It's also 3-dimensional poses such as the MayaPose, and the first part of just creating them is  almost identical to the MayaPose. Actually you can even convert between Cones and MayaPose with right-click on the interpolator!</p> <p>But then the algorithm they use for calculating the poses couldn't be more different - and  you have more options to adjust the timing. And you don't need to have a minimum of 4 poses! Even just one is enough.</p> <p>There's the attribute called Range, which is very important! Neglecting this will put you in trouble.</p> <p>The first thing you notice on the Range is that it starts from the higher value and goes to  the smaller value. The first important thing you have to pay attention to is that the Start (bigger value) needs to be equal or smaller than the positive rotation value, and not bigger than 89:  </p> <p>If you love math..</p> <p>Instead of positive rotation value the correct explanation is actually the angle difference. In the picture above the rotation is (0,0,-45) so the angle distance is 45. So even though the angle of the rotation has a negative value, the angle distance is still positive. If the rotation is (30,0,0), the angle distance would be 30. And If you have a more complex rotation such as (30,0,-80),  the rotation difference would be much harder to calculate, so try to avoid that.</p> <p>Another thing to be aware with cones is that by default they work great as the rig moves into the pose, but when it moves further, the pose fades out. And that can get very nasty.  Let's look at this example below (which happens a lot in production!). In here I have range as 15-0, so it starts at 15.  Now the issue is as soon as the arm goes just a bit further, the costume (sphere in this case) jumps back: </p> <p>Here's the solution - overshoot the rotation of the pose and set a higher end range:  And immediately it'll look much better!  </p> <p>Watch Out</p> <p>When you do a cone pose or mayaPose on the upper arm, make sure to set the spine end joint as the JointParent! Otherwise you'll hit issues when the clavicle moves around: </p>"},{"location":"body/poseEditor1/#upleg","title":"Upleg","text":"<p>This is a very specialized one just for upper leg rotating upwards like in a sitting pose.  While you could also do that with Cone or MayaPose, this one is a more special engineered for the uplegs going up. It has a few options such as fading out as the legs rotate outwards. And you can even control if and how much it  should fade out when the leg rotates inwards.</p>"},{"location":"body/poseEditor1/#custom","title":"Custom","text":"<p>The custom interpolator is good for 2 things:</p> <ol> <li>drive things by a control attribute  </li> <li>create your own interpolator type such as an Interpolate By Distance Node</li> </ol> <p> You can see CtrlAttrX, CtrlAttrY and CtrlAttrZ, but you don't need to use all of them you can just use CtrlAttrX and keep the others empty. DriverAttr is the attribute that actually drives the output. Basically the tool checks what value the DriverAttr has when the CtrlAttrs is 0, and when it reaches the pose. You can also think of the DriverAttr as an inbetween step between the CtrlAttr and the actual Pose Output.  In the example of creating an Interpolate By Distance: CtrlAttr would be from an Animator Ctrl, and DriverAttr would be the actual output value of the distance node.  </p> <p>Tip</p> <p>If you don't want to use DriverAttr, just give it the same as what you have for CtrlAttrX.  This would then be a simple driving pose by an attribute. </p> <p>Current Limitation</p> <p>Unfortunately at this time it only works when CtrlAttr starts at 0. If you have an attribute where for example the default is 1.0, this won't work.</p>"},{"location":"body/poseEditor1/#targets-manipulating-the-rig","title":"Targets - Manipulating the Rig","text":"<p>In the previous chapter we just created Interpolators that calculate the pose - but they didn't do anything yet. Now  we'll discuss what those Interpolators can actually drive. We can do either BlendShape Targets (Correctives), or Ctrl Targets. Both of them start in the same way, that you just drag&amp;drop a pose from the Interpolator Table into the Targets Table. If you drag more than one pose, then the Target is a combination of the poses, and you get that extra button (M or S) that lets you specify the blend mode - either Multiply or Smallest.  </p> <p>And next we can choose to do either a blendShape, manipulate a Ctrl.</p>"},{"location":"body/poseEditor1/#blendshape-targets","title":"BlendShape Targets","text":"<p>First specify the meshes you want to use for blendShapes by adding them into the Meshes Table And then select them again and click the EDIT MESH button. This tells the tool that whatever you  sculpt on the mesh will go into that Target.   </p> <p>To see it in action check this video:  </p>      Your browser does not support the video tag.  <p>The tool I used in this gif is Mesh Tools -&gt; Sculpting Tools -&gt; Grap Tool. But when you have the EDIT button  activated, you can also select vertices and move them. Or use some of the Geometry Tools like Smooth Vertices </p> <p>Kangaroo Tool Tip</p> <p>If you haven't tried out the Smooth Vertices tool yet,  sculpting correctives is where it most useful! Because many times we are dealing with vertices that are  collapsed, and we want to smooth them out again.</p> <p>Remember</p> <p>Don't forget to deactivate the EDIT button when you are done!</p>"},{"location":"body/poseEditor1/#ctrl-targets","title":"Ctrl Targets","text":"<p>When you create Targets on Ctrls, it just creates a Ctrl Locator for each Ctrl that you can move around</p>      Your browser does not support the video tag.  <p>Whenever you click the Add/Activate above the ctrls table button, it creates a locator if it doesn't exist yet and selects it. If  the locator already exists, it'll just select it.    So that's a multi functional button that you'll be clicking a lot.  </p> <p>Note</p> <p>It could be that you don't see the Locator right away. And the reason most of the time is that the attribute on the master group called Poses Loc VIS is set to Off. Just switch it to On and you should see it see the locator right away: </p> <p>In the ctrl hierarchy (outliner) you can see all the locators, for each target one. And those that are activated are shown while the others get hidden automatically. You can even adjust the poses without the UI, just by grabbing the locators in the outliner.  But most of the time you'll be faster to just select the locator by using the Add/Activate button</p>"},{"location":"body/poseEditor1/#dresetattrs","title":"dResetAttrs","text":"<p>When you have a for example deltaMush or a blendShape target that shrinks the  skin to avoid collisions, it would constantly get into the way of sculpting. It could also corrupt stuff when you export or apply the blendShapes. For that we can add some attributes into the dResetAttr dictionary. Just open it with the JSON Editor and add things in there. You can see by default it already has all the fk2ik switches that make sure you are in FK while setting poses </p> <p>Don't Forget</p> <p>Do not forget the dResetAttr! We might be tempted to not bother because we can get things done without touching it, but it can get very uncomfortable later when you realize that some deformer quietly corrupted your poses more and more whenever you built or published.</p>"},{"location":"body/poseEditor1/#mirror","title":"Mirror","text":"<p>For mirroring things it's very important that the names of the interpolators and Targets specify if it's a left, right or middle pose. So if an interpolator is called interp_signedAngle_NEW, it's a middle one! Name it properly to something like interp_l_elbow.  The _l_ in there tells that it's a left one. Similar for the targets. But if you renamed the interpolator properly before creating the target, the target usually already has a good name. </p>"},{"location":"body/poseEditor1/#mirror-interpolator","title":"Mirror Interpolator","text":"<p>For mirroring any target, you first have to mirror the Interpolator. Don't worry if you forget, he'll remind you. Right click on Interpolator -&gt; Mirror: </p>"},{"location":"body/poseEditor1/#flip-blendshape","title":"Flip BlendShape","text":"<p>For flipping blendShapes, we need to first tell him how to find and map the opposite vertices. We do that by setting the mirror table with the right click menu on the mesh in the Meshes Table:   Your options are:  </p> <ul> <li>middle mesh (edgeflow)</li> <li>middle mesh (vertex positions)</li> <li>middle mesh (face points)</li> <li>side meshes (ids)</li> <li>side meshes (vertex positions)</li> <li>side meshes (face points)  </li> </ul> <p>Edgeflow is that mirror algorithm where it takes a middle edge and with that finds all the other vertices by the edge connection patterns.</p> <p>Then to do the actual flipping: Right click on Target -&gt; Side:Pose Combinations and Flip Meshes </p> <p>Select Mesh</p> <p>Don't forget to select the mesh! </p>"},{"location":"body/poseEditor1/#split-into-leftright","title":"Split into Left/Right","text":"<p>Flipping does not work well in cases where you want to sculpt a little bit in the middle (central line of the character),  such as on upperLegUp shapes. It'd work great for just each side separately, but when you have left and right combined such as  in a sitting pose, it won't blend well together. Theoretically you could create one for left and one for right and then do a combination target for both together. But in most cases it's nicer to do the Split Target option.</p> <p>To do splitting - when sculpting it, have the EDIT button activated just on the left target (or the right one, wouldn't matter). So at first you end up with a situation where when you activate the left target, the right side gets activated the same time. And all you have to do is click Side:Pose Combinations and Split Current Combined Shape into Left/Right </p>"},{"location":"body/poseEditor1/#mirror-ctrls","title":"Mirror Ctrls","text":"<p>For the ctrls you just choose Side:Pose Combinations and Ctrls. You can do either the selected ctrls, or if you don't have any ctrls selected, he'll do all   </p>"},{"location":"body/poseEditor1/#export","title":"Export","text":"<p>Click the FillAndExport button. It fills the ddInterpolators and ddPoseData attributes, and  creates the file poseEditorExports.ma in the mayaImport folder.   </p>"},{"location":"body/poseEditor2/","title":"Pose Editor II","text":""},{"location":"body/poseEditor2/#model-change","title":"Model Change","text":"<p>Whenever the model changed, open the poseEditorExports.ma file from the Export -&gt; MayaImp tool, and import the new model. Then select the new model + the corresponding Blendshape Mesh you have in scene:   </p> <p>And then you have 2 buttons: Warp or BlendShape You can do blendShape when the topology is the same and you used the default invertExport option. For all other cases do Warp </p> <p>Note</p> <p>The selection order doesn't matter here. But it's important that the model you select has the same name! </p>"},{"location":"body/poseEditor2/#sharing-interpolators-between-rigs","title":"Sharing Interpolators between Rigs","text":"<p>It can be very helpful to share Interpolators between characters. And there are 2 ways:  </p>"},{"location":"body/poseEditor2/#in-the-poseeditor-ui","title":"In the PoseEditor UI","text":"<p>Right click on the interpolator -&gt; Copy. Then go to your other character, and right click -&gt; Paste </p> <p>Known bug</p> <p>Currently the Paste option doesn't show up unless you click on an existing interpolator. So if you want to paste an interpolator to a new character that doesn't have any interpolators yet, just create a dummy one that you delete again after.</p>"},{"location":"body/poseEditor2/#with-the-json-editor","title":"With the JSON Editor","text":"<p>Once you exported the setup with the Fill and Export from Scene button, you can open the JSON Editor by right click  on ddInterpolators attribute: </p> <p>Then having the interpolators you want to transfer selected, right click -&gt; Copy.  And then right click -&gt; paste on the same location in the other character.</p> <p>Check JSON Editor for more information.</p> <p>Note</p> <p>While you could also share Target Infos using the JSON Editor, we don't do that as often as sharing interpolators.</p>"},{"location":"body/poseEditor2/#useful-tools","title":"Useful tools","text":""},{"location":"body/poseEditor2/#multiply","title":"Multiply","text":"<p>The multiply tool just multiplies by a certain value. In this gif we just multiplied things by 0.0 to fix some artefacts:  But it doesn't stop there! You can also use the multiply tool to improve your shapes by using vertex soft selection and maybe even  multiply by something higher than 0, such as 0.3. </p> <p>Note</p> <p>You see a similar tool under the right click menu of the targets called Erase. That's pretty much the same as  multiply by 0.0.</p>"},{"location":"body/poseEditor2/#warp","title":"Warp","text":"<p>The warp tool can warp secondary meshes. Most of the time we sculpt things on the main mesh such as the skin. And then we just warp to secondary meshes such as costume. To do that, put the skin mesh (body_geo) into the Master field, select all the targets, select the mesh in the scene, and then TOOLS -&gt; Warp ...  </p> <p>Known Bug</p> <p>At this time the warp tool expects you to already have the mesh inside the mesh table and have it activated for all targets. Basically what you get when you check the mesh having all targets selected. If you don't do that, it'll either quietly do nothing, or give you a strange error.</p> <p>Note</p> <p>Don't forget to have the mesh that you want to warp selected in scene. Btw, you can also do vertex and soft selection for that, and it'll only warp the vertices you have selected.</p>"},{"location":"body/poseEditor2/#blend-ids","title":"Blend IDs","text":"<p>If you have another mesh that has the pose sculpted already, the Blend IDs tool can help you with that, also under  the TOOLS button.</p>"},{"location":"body/poseEditor2/#known-issues","title":"Known Issues","text":""},{"location":"body/poseEditor2/#sometimes-the-interpolator-doesnt-update-anymore-even-though-im-100-sure-my-settings-are-correct","title":"Sometimes the Interpolator doesn't update anymore, even though I'm 100 % sure my settings are correct.","text":"<p>This is often an evaluation problem that happens if the rig is either very complex, or if there's a cycle in there. But there's a workaround: select the interpolator, and set right click -&gt; rebuild.  </p>"},{"location":"body/poseEditor2/#when-i-export-using-the-fill-and-export-button-he-exports-the-whole-rig","title":"When I export using the Fill and Export button, he exports the whole rig.","text":"<p>Check if you have some connections going from the meshes inside the _poseEditorExport group. Sometimes it could be a set. You can also try to just delete all your sets in scene</p>"},{"location":"builder/builderGeneral/","title":"Builder General","text":""},{"location":"builder/builderGeneral/#what-is-the-builder","title":"What is the builder?","text":"<p>The Builder is the first most important tool that you need to get familiar with for creating characters.</p> <p>The builder is basically a central tool that manages a ton of Python functions from different files, and lets you run them. Either just selected functions or all at once for the final creation using the Run All button.</p> <p>Go to that character you created from the previous section and click Run All Now sit back and enjoy watching him build the character for you: </p> <p>Take a moment to get familiar with the UI: </p> <p>At the top you have Python Files. You can add files, remove files or you can even uncheck them and then all their functions will disappear. Below are the actual functions. Even further below you can set function arguments for the function that you have selected. And on the right side you can see buttons and a description for  whatever function you have selected.</p> <p>Note</p> <p>If you don't see the right section, you might have to drag the splitter a bit: </p> <p>You can also create your own python functions and specify arguments and build buttons. But more to that in Python - Simple way of adding a function section. For now let's check out some of the more important functions that we automatically.  </p>"},{"location":"builder/builderGeneral/#the-functions","title":"The Functions","text":""},{"location":"builder/builderGeneral/#importmodel","title":"importModel()","text":"<p>The importModel() function imports the model.  If you copied from BASEHUMAN, it's just that boring grey guy.  If you already have a model, go to export -&gt; MODEL, and with the Explorer New Model button you get a folder that let's you copy a character in it  </p> <p>Note</p> <p>If you work in a company that has their own studio pipeline for handling assets, you might want to grab the model automatically from the studio pipeline. To see how to do that, go to Python - Connecting to a Studio Pipeline. Basically you'd create a script that looks for the corresponding character model file in your studio pipeline.</p>"},{"location":"builder/builderGeneral/#importblueprints-buildpuppet","title":"importBlueprints(), buildPuppet()","text":"<p>importBlueprints() and buildPuppet() are the functions for grabbing the work you do in the Puppet Tool.  It's for creating the main controls and rigging logic like Iks, Fks, Auto Clavicle, ... Check Puppet for more detail. </p>"},{"location":"builder/builderGeneral/#loadctrlshapes","title":"loadCtrlShapes()","text":"<p>This loads the ctrl shapes. To export the ctrls shapes that he should load - go to Ctrls -&gt; Export -&gt; Export All Ctrls:   This just exports the shape of all ctrls in scene.  </p>"},{"location":"builder/builderGeneral/#loaddeformers","title":"loadDeformers()","text":"<p>This loads all the deformers (mainly skinCluster weights) from the deformers folder.  You can export the deformers in Export -&gt; Deformers </p> <p>Kangaroo Tool Tip</p> <p>To use this function most efficiently it's best to get familiar with everything on Deformer Import Tool</p> <p>Limitation</p> <p>This only saves/loads weights, attribute values and deformer orders. It does NOT load deformer structures such as blendShape targets, or full wrap deformer setups. Because there are more optimized tools (see  Pose Editor, Shape Editor, Python - adding function and Python Library - Create Deformers) But easy deformers like deltaMush that mainly just need weights and attribute values can be handled just in the loadDeformers() function.</p> <p>Joints at the Origin</p> <p>When you are loading the skinCluster weights, many times you'll see that some of the joints are just simple joints  on the origin. </p> <p>This is not always bad, it could mean one of two things:</p> <ol> <li>when you exported, there was a joint weighted which due to new changes you did, the joint doesn't exist anymore. In that case the skincluster Move tool can help you to move the weights to where they should be</li> <li>Many setup functions especially in the face are happening after the loadDeformers() function. In those cases the loadDeformers() function will just create the simple joints since they don't exist yet. And then  the function later is smart enough to recognize them and put them into the proper place</li> </ol>"},{"location":"builder/builderGeneral/#importmayafiles","title":"importMayaFiles()","text":"<p>This just imports simple maya files: </p> <p>To add files that he should import - go to  Export -&gt; MayaImp,</p> <p>If you want to quickly check what files are there, you can do that with right click: </p>"},{"location":"builder/builderGeneral/#importtargets","title":"importTargets()","text":"<p>Very similar to importMayaFiles(). But Targets are just simple Polygon Meshes. Those are saved with a Numpy file format that keeps the files smaller. Obvously the file might be even smaller if you save it as a dummy blendShape and add a builder function that extracts it (and some kangaroo tools do exactly that), but there are many situations where you have some simple meshes and you don't want to go through that hassle. If you go to Export -&gt; Targets, you can export the selected meshes. By default it creates a file for each mesh and the mesh name is defined in the file name.  This makes it very easy to manage later</p>"},{"location":"builder/builderGeneral/#theres-more","title":"There's more...","text":"<p>Now you've just seen the important basic functions. But there's a looooot more, like all the green ones. And later for the Face we'll add lots of orange functions.</p>"},{"location":"builder/builderGeneral/#custom-functions","title":"Custom Functions","text":"<p>You can create your own functions in Python and declare your own arguments and builder buttons.  See Python - simple way of adding functions and  Python - Create Extra Builds.</p>"},{"location":"builder/builderGeneral/#buildbld-file","title":"build.bld file","text":"<p>Everything you do in the builder like adding files, check/uncheck functions, setting function variables, or even just selecting stuff - gets saved in the build.bld file.  </p> <p>The build.bld file is a JSON file, so with a text editor you could theoretically adjust it. But we do that mainly just for debugging purposes.</p> <p>Whenever you do a wrong click such badly setting some variables that you'd like to undo - Don't Panic! Just click on the Backup button at the top right and choose an older one to switch to. You might even need to use that button if your build file gets corrupted from a crash. </p>"},{"location":"builder/jsonEditor/","title":"JSON Editor","text":"<p>The JSON Editor is a tool inside the builder that lets you edit complex attributes. By complex attributes we are talking about dictionaries or lists that can have other lists/dictionaries embedded - all defined as a single string value.  </p> <p>Imagine you have a very long string that defines this python dictionary:</p> <pre><code>{'fingerInterp_l_indexA': {'bComputeInParentSpace': False, 'iAngleAxis': 2, 'iUpAxis': 0, 'sCtrlAttr': 'indexBase_l_ctrl.rx', 'sInterpType': 'signedAngle', 'sParent': 'jnt_l_indexMeta', 'sTwist': 'jnt_l_indexBase', 'xPoses': [['down', [20.0, 90.0], 1], ['up', [0.0, -80.0], 1]]}, 'fingerInterp_l_indexB': {'bComputeInParentSpace': False, 'iAngleAxis': 2, 'iUpAxis': 0, 'sCtrlAttr': 'indexMid_l_ctrl.rx', 'sInterpType': 'signedAngle', 'sParent': 'jnt_l_indexBase', 'sTwist': 'jnt_l_indexMid', 'xPoses': [['down', [20.0, 90.0], 1], ['up', [0.0, -45.0], 1]]}, 'fingerInterp_l_indexC': {'bComputeInParentSpace': False, 'iAngleAxis': 2, 'iUpAxis': 0, 'sCtrlAttr': 'indexTip_l_ctrl.rx', 'sInterpType': 'signedAngle', 'sParent': 'jnt_l_indexMid', 'sTwist': 'jnt_l_indexTip', 'xPoses': [['down', [20.0, 90.0], 1], ['up', [0.0, -45.0], 1]]}, 'fingerInterp_l_middleA': {'bComputeInParentSpace': False, 'iAngleAxis': 2, 'iUpAxis': 0, 'sCtrlAttr': 'middleBase_l_ctrl.rx', 'sInterpType': 'signedAngle', 'sParent': 'jnt_l_middleMeta', 'sTwist': 'jnt_l_middleBase', 'xPoses': [['down', [20.0, 90.0], 1], ['up', [0.0, -80.0], 1]]}, 'fingerInterp_l_middleB': {'bComputeInParentSpace': False, 'iAngleAxis': 2, 'iUpAxis': 0, 'sCtrlAttr': 'middleMid_l_ctrl.rx', 'sInterpType': 'signedAngle', 'sParent': 'jnt_l_middleBase', 'sTwist': 'jnt_l_middleMid', 'xPoses': [['down', [20.0, 90.0], 1], ['up', [0.0, -45.0], 1]]}, 'fingerInterp_l_middleC': {'bComputeInParentSpace': False, 'iAngleAxis': 2, 'iUpAxis': 0, 'sCtrlAttr': 'middleTip_l_ctrl.rx', 'sInterpType': 'signedAngle', 'sParent': 'jnt_l_middleMid', 'sTwist': 'jnt_l_middleTip', 'xPoses': [['down', [20.0, 90.0], 1], ['up', [0.0, -45.0], 1]]}, 'fingerInterp_l_pinkyA': {'bComputeInParentSpace': False, 'iAngleAxis': 2, 'iUpAxis': 0, 'sCtrlAttr': 'pinkyBase_l_ctrl.rx', 'sInterpType': 'signedAngle', 'sParent': 'jnt_l_pinkyMeta', 'sTwist': 'jnt_l_pinkyBase', 'xPoses': [['down', [20.0, 90.0], 1], ['up', [0.0, -80.0], 1]]}, 'fingerInterp_l_pinkyB': {'bComputeInParentSpace': False, 'iAngleAxis': 2, 'iUpAxis': 0, 'sCtrlAttr': 'pinkyMid_l_ctrl.rx', 'sInterpType': 'signedAngle', 'sParent': 'jnt_l_pinkyBase', 'sTwist': 'jnt_l_pinkyMid', 'xPoses': [['down', [20.0, 90.0], 1], ['up', [0.0, -45.0], 1]]}, 'fingerInterp_l_pinkyC': {'bComputeInParentSpace': False, 'iAngleAxis': 2, 'iUpAxis': 0, 'sCtrlAttr': 'pinkyTip_l_ctrl.rx', 'sInterpType': 'signedAngle', 'sParent': 'jnt_l_pinkyMid', 'sTwist': 'jnt_l_pinkyTip', 'xPoses': [['down', [20.0, 90.0], 1], ['up', [0.0, -45.0], 1]]}, 'fingerInterp_l_thumbA': {'bComputeInParentSpace': False, 'iAngleAxis': 2, 'iUpAxis': 0, 'sCtrlAttr': 'thumbMeta_l_ctrl.rx', 'sInterpType': 'signedAngle', 'sParent': 'jnt_l_armWrist', 'sTwist': 'jnt_l_thumbMeta', 'xPoses': [['down', [0.0, 50.0], 1], ['up', [0.0, -50.0], 1]]}, 'fingerInterp_l_thumbB': {'bComputeInParentSpace': False, 'iAngleAxis': 2, 'iUpAxis': 0, 'sCtrlAttr': 'thumbBase_l_ctrl.rx', 'sInterpType': 'signedAngle', 'sParent': 'jnt_l_thumbMeta', 'sTwist': 'jnt_l_thumbBase', 'xPoses': [['down', [20.0, 90.0], 1], ['up', [0.0, -60.0], 1]]}, 'fingerInterp_l_thumbC': {'bComputeInParentSpace': False, 'iAngleAxis': 2, 'iUpAxis': 0, 'sCtrlAttr': 'thumbMid_l_ctrl.rx', 'sInterpType': 'signedAngle', 'sParent': 'jnt_l_thumbBase', 'sTwist': 'jnt_l_thumbMid', 'xPoses': [['down', [20.0, 60.0], 1], ['up', [0.0, -60.0], 1]]}, 'fingerInterp_r_indexA': {'bComputeInParentSpace': False, 'iAngleAxis': 2, 'iUpAxis': 0, 'sCtrlAttr': 'indexBase_r_ctrl.rx', 'sInterpType': 'signedAngle', 'sParent': 'jnt_r_indexMeta', 'sTwist': 'jnt_r_indexBase', 'xPoses': [['down', [20.0, 90.0], 1], ['up', [0.0, -80.0], 1]]}, 'fingerInterp_r_indexB': {'bComputeInParentSpace': False, 'iAngleAxis': 2, 'iUpAxis': 0, 'sCtrlAttr': 'indexMid_r_ctrl.rx', 'sInterpType': 'signedAngle', 'sParent': 'jnt_r_indexBase', 'sTwist': 'jnt_r_indexMid', 'xPoses': [['down', [20.0, 90.0], 1], ['up', [0.0, -45.0], 1]]}, 'fingerInterp_r_indexC': {'bComputeInParentSpace': False, 'iAngleAxis': 2, 'iUpAxis': 0, 'sCtrlAttr': 'indexTip_r_ctrl.rx', 'sInterpType': 'signedAngle', 'sParent': 'jnt_r_indexMid', 'sTwist': 'jnt_r_indexTip', 'xPoses': [['down', [20.0, 90.0], 1], ['up', [0.0, -45.0], 1]]}, 'fingerInterp_r_middleA': {'bComputeInParentSpace': False, 'iAngleAxis': 2, 'iUpAxis': 0, 'sCtrlAttr': 'middleBase_r_ctrl.rx', 'sInterpType': 'signedAngle', 'sParent': 'jnt_r_middleMeta', 'sTwist': 'jnt_r_middleBase', 'xPoses': [['down', [20.0, 90.0], 1], ['up', [0.0, -80.0], 1]]}, 'fingerInterp_r_middleB': {'bComputeInParentSpace': False, 'iAngleAxis': 2, 'iUpAxis': 0, 'sCtrlAttr': 'middleMid_r_ctrl.rx', 'sInterpType': 'signedAngle', 'sParent': 'jnt_r_middleBase', 'sTwist': 'jnt_r_middleMid', 'xPoses': [['down', [20.0, 90.0], 1], ['up', [0.0, -45.0], 1]]}, 'fingerInterp_r_middleC': {'bComputeInParentSpace': False, 'iAngleAxis': 2, 'iUpAxis': 0, 'sCtrlAttr': 'middleTip_r_ctrl.rx', 'sInterpType': 'signedAngle', 'sParent': 'jnt_r_middleMid', 'sTwist': 'jnt_r_middleTip', 'xPoses': [['down', [20.0, 90.0], 1], ['up', [0.0, -45.0], 1]]}, 'fingerInterp_r_pinkyA': {'bComputeInParentSpace': False, 'iAngleAxis': 2, 'iUpAxis': 0, 'sCtrlAttr': 'pinkyBase_r_ctrl.rx', 'sInterpType': 'signedAngle', 'sParent': 'jnt_r_pinkyMeta', 'sTwist': 'jnt_r_pinkyBase', 'xPoses': [['down', [20.0, 90.0], 1], ['up', [0.0, -80.0], 1]]}, 'fingerInterp_r_pinkyB': {'bComputeInParentSpace': False, 'iAngleAxis': 2, 'iUpAxis': 0, 'sCtrlAttr': 'pinkyMid_r_ctrl.rx', 'sInterpType': 'signedAngle', 'sParent': 'jnt_r_pinkyBase', 'sTwist': 'jnt_r_pinkyMid', 'xPoses': [['down', [20.0, 90.0], 1], ['up', [0.0, -45.0], 1]]}, 'fingerInterp_r_pinkyC': {'bComputeInParentSpace': False, 'iAngleAxis': 2, 'iUpAxis': 0, 'sCtrlAttr': 'pinkyTip_r_ctrl.rx', 'sInterpType': 'signedAngle', 'sParent': 'jnt_r_pinkyMid', 'sTwist': 'jnt_r_pinkyTip', 'xPoses': [['down', [20.0, 90.0], 1], ['up', [0.0, -45.0], 1]]}, 'fingerInterp_r_thumbA': {'bComputeInParentSpace': False, 'iAngleAxis': 2, 'iUpAxis': 0, 'sCtrlAttr': 'thumbMeta_r_ctrl.rx', 'sInterpType': 'signedAngle', 'sParent': 'jnt_r_armWrist', 'sTwist': 'jnt_r_thumbMeta', 'xPoses': [['down', [0.0, 50.0], 1], ['up', [0.0, -50.0], 1]]}, 'fingerInterp_r_thumbB': {'bComputeInParentSpace': False, 'iAngleAxis': 2, 'iUpAxis': 0, 'sCtrlAttr': 'thumbBase_r_ctrl.rx', 'sInterpType': 'signedAngle', 'sParent': 'jnt_r_thumbMeta', 'sTwist': 'jnt_r_thumbBase', 'xPoses': [['down', [20.0, 90.0], 1], ['up', [0.0, -60.0], 1]]}, 'fingerInterp_r_thumbC': {'bComputeInParentSpace': False, 'iAngleAxis': 2, 'iUpAxis': 0, 'sCtrlAttr': 'thumbMid_r_ctrl.rx', 'sInterpType': 'signedAngle', 'sParent': 'jnt_r_thumbBase', 'sTwist': 'jnt_r_thumbMid', 'xPoses': [['down', [20.0, 60.0], 1], ['up', [0.0, -60.0], 1]]}, 'interp_l_clavicle': {'bJointAngleFactor': 0.0, 'iCtrlTwistAxis': 1.0, 'sCtrl': 'clavicle_l_ctrl', 'sInterpType': 'cone', 'sJoint': 'jnt_l_clavicleMain', 'sJointParent': 'jnt_m_spineSpine_end', 'xPoses': [['up', [0.0, 0.0, -35.0], [35.0, 0.0], 1, 0.0], ['upLater', [0.0, 0.0, -35.0], [20.0, 0.0], 0, 0.0], ['forward', [-59.99999999999999, 0.0, 0.0], [60.0, 30.0], 0, 0.0]]}, 'interp_l_clavicleMayaPose': {'sCtrl': 'clavicle_l_ctrl', 'sInterpType': 'mayaPose', 'sJoint': 'jnt_l_clavicleMain', 'sJointParent': 'jnt_m_spineSpine_end', 'xPoses': [['up', 0.0, 0.0, -35.0], ['forward', -30.0, 0.0, 0.0], ['down', 0.0, 0.0, 29.999999999999996], ['back', 29.999999999999996, 0.0, 0.0], ['upForward', -25.0, 0.0, -25.0]]}, 'interp_l_elbow': {'bComputeInParentSpace': False, 'iAngleAxis': 2, 'iUpAxis': 0, 'sCtrlAttr': 'armElbow_l_ctrl.rx', 'sInterpType': 'signedAngle', 'sParent': 'jnt_l_arm_upperTwist_003', 'sTwist': 'jnt_l_arm_lowerTwist_000', 'xPoses': [['back', [0, 90], 1], ['forward', [0, -90], 1], ['forward2', [0.0, -130.0], 1]]}, 'interp_l_foot': {'bJointAngleFactor': 0.0, 'iCtrlTwistAxis': 1.0, 'sCtrl': 'legAnkle_l_ctrl', 'sInterpType': 'cone', 'sJoint': 'jnt_l_legWrist', 'sJointParent': 'jnt_l_leg_lowerTwist_003', 'xPoses': [['forward', [90.0, 0.0, 0.0], [89.0, 45.0], 1, 0.0], ['back', [-90.0, 0.0, 0.0], [89.0, 25.0], 1, 0.0], ['left', [0.0, 0.0, 80.0], [89.0, 0.0], 1, 0.0], ['right', [0.0, 0.0, -80.0], [89.0, 0.0], 1, 0.0]]}, 'interp_l_knee': {'bComputeInParentSpace': False, 'iAngleAxis': 2, 'iUpAxis': 0, 'sCtrlAttr': 'legKnee_l_ctrl.rx', 'sInterpType': 'signedAngle', 'sParent': 'jnt_l_leg_upperTwist_003', 'sTwist': 'jnt_l_leg_lowerTwist_000', 'xPoses': [['forward', [0.0, 20.0], 1], ['back', [0, -90], 1]]}, 'interp_l_toes': {'bComputeInParentSpace': False, 'iAngleAxis': 2, 'iUpAxis': 0, 'sCtrlAttr': 'legToesFK_l_ctrl.rx', 'sInterpType': 'signedAngle', 'sParent': 'jnt_l_legWrist', 'sTwist': 'jnt_l_legFingers', 'xPoses': [['forward', [0.0, 60.0], 1], ['back', [0, -90], 1]]}, 'interp_l_upleg_cone': {'bJointAngleFactor': 0.0, 'iCtrlTwistAxis': 1.0, 'sCtrl': 'legUpper_l_ctrl', 'sInterpType': 'cone', 'sJoint': 'jnt_l_leg_upperTwist_000', 'sJointParent': 'jnt_l_hip', 'xPoses': [['smallBack', [-20.0, 0.0, 0.0], [20.0, 0.0], 1, 0.0], ['smallForward', [27.0, 6.074551084330768e-15, -5.55281883123711e-07], [15.0, 0.0], 3, 0.0], ['smallDiagonal', [85.0, 0.0, 20.0], [35.0, 0.0], 0, 0.0]]}, 'interp_l_upleg_upIn': {'sCtrlAttrs': ['legUpper_l_ctrl.rx', 'legUpper_l_ctrl.rz', ''], 'sDriverAttr': 'jnt_l_leg_lowerTwist_000.inHipsHorizontal', 'sInterpType': 'custom', 'xPoses': [['on', [90.0, -10.0, 0.0], 1]]}, 'interp_l_upperArm': {'bJointAngleFactor': 0.0, 'iCtrlTwistAxis': 1.0, 'sCtrl': 'armUpper_l_ctrl', 'sInterpType': 'cone', 'sJoint': 'jnt_l_arm_upperTwist_000', 'sJointParent': 'jnt_m_spineSpine_end', 'xPoses': [['down', [0.0, 0.0, 115.0], [45.0, 35.0], 1, 0.0], ['forward', [-100.0, 0.0, 0.0], [89.0, 0.0], 0, 0.0], ['up', [0.0, 0.0, -80.0], [60.0, 30.0], 0, 0.0], ['upStartImmediately', [0.0, 0.0, -50.0], [50.0, 0.0], 0, 0.0], ['fixCuffsOnForward', [-55.0, -25.0, -25.0], [25.0, 0.0], 0, 0.0]]}, 'interp_l_upperArmUpDown': {'bComputeInParentSpace': False, 'iAngleAxis': 1, 'iUpAxis': 0, 'sCtrlAttr': 'armUpper_l_ctrl.rz', 'sInterpType': 'signedAngle', 'sParent': 'jnt_m_spineSpine_end', 'sTwist': 'jnt_l_arm_upperTwist_000', 'xPoses': [['down', [0.0, 80.0], 1], ['up', [0.0, -45.0], 1], ['downEnd', [65.0, 80.0], 1]]}, 'interp_l_wrist': {'bJointAngleFactor': 0.0, 'iCtrlTwistAxis': 1.0, 'sCtrl': 'armWrist_l_ctrl', 'sInterpType': 'cone', 'sJoint': 'jnt_l_armWrist', 'sJointParent': 'jnt_l_arm_lowerTwist_003', 'xPoses': [['down', [0.0, 0.0, 80.0], [80.0, 0.0], 1, 0.0], ['up', [0.0, 0.0, -80.0], [80.0, 0.0], 1, 0.0]]}, 'interp_m_head': {'sCtrl': 'head_ctrl', 'sInterpType': 'mayaPose', 'sJoint': 'jnt_m_headMain', 'sJointParent': 'jnt_m_neckSpine_001', 'xPoses': [['forward', 35.0, 0.0, 0.0], ['back', -45.0, 0.0, 0.0], ['right', 0.0, 0.0, 35.0], ['left', 0.0, 0.0, -35.0]]}, 'interp_neckBase': {'bJointAngleFactor': 0.0, 'iCtrlTwistAxis': 1.0, 'sCtrl': 'neckA_ctrl', 'sInterpType': 'cone', 'sJoint': 'jnt_m_neckSpine_000', 'sJointParent': 'jnt_m_spineSpine_end', 'xPoses': [['back', [-55.0, 0.0, 0.0], [55.0, 35.0], 1, 0.0]]}, 'interp_r_clavicle': {'bJointAngleFactor': 0.0, 'iCtrlTwistAxis': 1.0, 'sCtrl': 'clavicle_r_ctrl', 'sInterpType': 'cone', 'sJoint': 'jnt_r_clavicleMain', 'sJointParent': 'jnt_m_spineSpine_end', 'xPoses': [['up', [0.0, 0.0, -35.0], [35.0, 0.0], 1, 0.0], ['upLater', [0.0, 0.0, -35.0], [20.0, 0.0], 0, 0.0], ['forward', [-59.99999999999999, 0.0, 0.0], [60.0, 30.0], 0, 0.0]]}, 'interp_r_clavicleMayaPose': {'sCtrl': 'clavicle_r_ctrl', 'sInterpType': 'mayaPose', 'sJoint': 'jnt_r_clavicleMain', 'sJointParent': 'jnt_m_spineSpine_end', 'xPoses': [['up', 0.0, 0.0, -35.0], ['forward', -30.0, 0.0, 0.0], ['down', 0.0, 0.0, 29.999999999999996], ['back', 29.999999999999996, 0.0, 0.0], ['upForward', -25.0, 0.0, -25.0]]}, 'interp_r_elbow': {'bComputeInParentSpace': False, 'iAngleAxis': 2, 'iUpAxis': 0, 'sCtrlAttr': 'armElbow_r_ctrl.rx', 'sInterpType': 'signedAngle', 'sParent': 'jnt_r_arm_upperTwist_003', 'sTwist': 'jnt_r_arm_lowerTwist_000', 'xPoses': [['back', [0, 90], 1], ['forward', [0, -90], 1], ['forward2', [0.0, -130.0], 1]]}, 'interp_r_foot': {'bJointAngleFactor': 0.0, 'iCtrlTwistAxis': 1.0, 'sCtrl': 'legAnkle_r_ctrl', 'sInterpType': 'cone', 'sJoint': 'jnt_r_legWrist', 'sJointParent': 'jnt_r_leg_lowerTwist_003', 'xPoses': [['forward', [90.0, 0.0, 0.0], [89.0, 45.0], 1, 0.0], ['back', [-90.0, 0.0, 0.0], [89.0, 25.0], 1, 0.0], ['left', [0.0, 0.0, 80.0], [89.0, 0.0], 1, 0.0], ['right', [0.0, 0.0, -80.0], [89.0, 0.0], 1, 0.0]]}, 'interp_r_knee': {'bComputeInParentSpace': False, 'iAngleAxis': 2, 'iUpAxis': 0, 'sCtrlAttr': 'legKnee_r_ctrl.rx', 'sInterpType': 'signedAngle', 'sParent': 'jnt_r_leg_upperTwist_003', 'sTwist': 'jnt_r_leg_lowerTwist_000', 'xPoses': [['forward', [0.0, 20.0], 1], ['back', [0, -90], 1]]}, 'interp_r_toes': {'bComputeInParentSpace': False, 'iAngleAxis': 2, 'iUpAxis': 0, 'sCtrlAttr': 'legToesFK_r_ctrl.rx', 'sInterpType': 'signedAngle', 'sParent': 'jnt_r_legWrist', 'sTwist': 'jnt_r_legFingers', 'xPoses': [['forward', [0.0, 60.0], 1], ['back', [0, -90], 1]]}, 'interp_r_upleg_cone': {'bJointAngleFactor': 0.0, 'iCtrlTwistAxis': 1.0, 'sCtrl': 'legUpper_r_ctrl', 'sInterpType': 'cone', 'sJoint': 'jnt_r_leg_upperTwist_000', 'sJointParent': 'jnt_r_hip', 'xPoses': [['smallBack', [-20.0, 0.0, 0.0], [20.0, 0.0], 1, 0.0], ['smallForward', [27.0, 6.074551084330768e-15, -5.55281883123711e-07], [15.0, 0.0], 3, 0.0], ['smallDiagonal', [85.0, 0.0, 20.0], [35.0, 0.0], 0, 0.0]]}, 'interp_r_upleg_upIn': {'sCtrlAttrs': ['legUpper_r_ctrl.rx', 'legUpper_r_ctrl.rz', ''], 'sDriverAttr': 'jnt_r_leg_lowerTwist_000.inHipsHorizontal', 'sInterpType': 'custom', 'xPoses': [['on', [90.0, -10.0, 0.0], 1]]}, 'interp_r_upperArm': {'bJointAngleFactor': 0.0, 'iCtrlTwistAxis': 1.0, 'sCtrl': 'armUpper_r_ctrl', 'sInterpType': 'cone', 'sJoint': 'jnt_r_arm_upperTwist_000', 'sJointParent': 'jnt_m_spineSpine_end', 'xPoses': [['down', [0.0, 0.0, 115.0], [45.0, 35.0], 1, 0.0], ['forward', [-100.0, 0.0, 0.0], [89.0, 0.0], 0, 0.0], ['up', [0.0, 0.0, -80.0], [60.0, 30.0], 0, 0.0], ['upStartImmediately', [0.0, 0.0, -50.0], [50.0, 0.0], 0, 0.0], ['fixCuffsOnForward', [-55.0, -25.0, -25.0], [25.0, 0.0], 0, 0.0]]}, 'interp_r_upperArmUpDown': {'bComputeInParentSpace': False, 'iAngleAxis': 1, 'iUpAxis': 0, 'sCtrlAttr': 'armUpper_r_ctrl.rz', 'sInterpType': 'signedAngle', 'sParent': 'jnt_m_spineSpine_end', 'sTwist': 'jnt_r_arm_upperTwist_000', 'xPoses': [['down', [0.0, 80.0], 1], ['up', [0.0, -45.0], 1], ['downEnd', [65.0, 80.0], 1]]}, 'interp_r_wrist': {'bJointAngleFactor': 0.0, 'iCtrlTwistAxis': 1.0, 'sCtrl': 'armWrist_r_ctrl', 'sInterpType': 'cone', 'sJoint': 'jnt_r_armWrist', 'sJointParent': 'jnt_r_arm_lowerTwist_003', 'xPoses': [['down', [0.0, 0.0, 80.0], [80.0, 0.0], 1, 0.0], ['up', [0.0, 0.0, -80.0], [80.0, 0.0], 1, 0.0]]}, 'interp_spineA': {'bJointAngleFactor': 1.0, 'iCtrlTwistAxis': 1.0, 'sCtrl': 'spineSplineFk_A_ctrl', 'sInterpType': 'cone', 'sJoint': 'jnt_m_spineSpine_001', 'sJointParent': 'jnt_m_spineSpine_000', 'xPoses': [['forward', [75.0, 0.0, 0.0], [75.0, 45.0], 1, 0.0], ['back', [-75.0, 0.0, 0.0], [75.0, 45.0], 1, 0.0]]}, 'interp_spineB': {'bJointAngleFactor': 1.0, 'iCtrlTwistAxis': 1.0, 'sCtrl': 'spineSplineFk_B_ctrl', 'sInterpType': 'cone', 'sJoint': 'jnt_m_spineSpine_003', 'sJointParent': 'jnt_m_spineSpine_002', 'xPoses': [['forward', [90.0, 0.0, 0.0], [80.0, 45.0], 1, 0.0], ['back', [-90.0, 0.0, 0.0], [80.0, 0.0], 1, 0.0]]}, 'interp_spineC': {'bJointAngleFactor': 1.0, 'iCtrlTwistAxis': 1.0, 'sCtrl': 'spineSplineFk_C_ctrl', 'sInterpType': 'cone', 'sJoint': 'jnt_m_spineSpine_005', 'sJointParent': 'jnt_m_spineSpine_004', 'xPoses': [['back', [-90.0, 0.0, 0.0], [89.0, 55.0], 1, 0.0], ['forward', [90.0, 0.0, 0.0], [89.0, 65.0], 0, 0.0]]}, 'interp_spineC_twist': {'bComputeInParentSpace': False, 'iAngleAxis': 0, 'iUpAxis': 1, 'sCtrlAttr': 'spineSplineFk_C_ctrl.ry', 'sInterpType': 'signedAngle', 'sParent': 'jnt_m_spineSpine_004', 'sTwist': 'jnt_m_spineSpine_005', 'xPoses': [['left', [0.0, 45.0], 1], ['right', [0.0, -45.0], 1]]}, 'interp_uplegUp_l': {'bReverses': [False, False, True], 'fKneeStarts': [0.25, 0.0, 0.25], 'fTurnOffOnIns': [0.0, 0.0, 0.0], 'fUpRotations': [90.0, 30.0, 90.0], 'sInterpType': 'upleg', 'sPoseNames': ['up', 'upEarlier', 'upRev']}, 'interp_uplegUp_r': {'bReverses': [False, False, True], 'fKneeStarts': [0.25, 0.0, 0.25], 'fTurnOffOnIns': [0.0, 0.0, 0.0], 'fUpRotations': [90.0, 30.0, 90.0], 'sInterpType': 'upleg', 'sPoseNames': ['up', 'upEarlier', 'upRev']}}\n</code></pre> <p>It would be a nightmare to adjust that directly. But with the JSON Editor it's a charm: </p> <p>And it's very straight forward to use. You have all those tools, which for the most part you can find in the right click menu:</p> <ul> <li>duplicate</li> <li>copy/paste</li> <li>rename</li> <li>remove</li> <li>filter items fields at the top of each column</li> <li>ordering items with up/down buttons (only appear on lists)</li> </ul> <p>Look at how few clicks are needed to remove all pinky items:   </p>"},{"location":"builder/workflowTricks/","title":"Workflow Tricks","text":""},{"location":"builder/workflowTricks/#hold-pull","title":"Hold, Pull","text":"<p>The Hold button at the top left of the UI just saves the current scene into the _temp folder of your character with a very simple name.  And every time you click Hold again, it'll save another version and just increments the number. And when you click Pull, it opens whatever you saved last. And with a right click on the Pull button you can either open an older version or Reference it. Or you can copy it to clipboard so you can get the path with CTRL+P  And he will delete older files automatically when you click Push. He'll basically just keep the current temp file count to a specific number. He'll actually tell you that in the log:  </p>"},{"location":"builder/workflowTricks/#selection-templates","title":"Selection Templates","text":"<p>Selection Templates is the ST button on the right. By default it lets you select all the functions until LoadDeformers() or all the functions until beforeClean(). And with right mouse click you can define your own selection templates. </p> <p>Note</p> <p>If you wonder why we build until clean(): The clean() functions are basically cleaning the scene. You'll learn more about it later, but for some things like muscle joints or debugging skinCluster it's great to just build until before clean.</p>"},{"location":"builder/workflowTricks/#undo-run-selected","title":"Undo + Run Selected","text":"<p>If you trying to build the whole character, and it suddenly breaks at once function, you can just fix for example the python code or attributes, and click Undo+Run Selected, without having to run everything from the beginning. Basically the builder remembers the undo position before each function and then later can do lots of undos in a row until he'll get to wherever it was before the function. Unfortunately that doesn't work whenever the function does something that's not undo supported such as importing or referencing  a maya scene.</p>"},{"location":"face/brows/","title":"Brows","text":""},{"location":"face/brows/#blendshapes","title":"BlendShapes","text":"<p>The blendShape targets that you can sculpt in the ShapeEditor are: <pre><code>    innerBrowDown\n    innerBrowUp\n    browIn\n    browOut\n    outerBrowUp\n    outerBrowDown\n</code></pre></p> <p>Note</p> <p>There are some additional corrective targets that can be sculpted, but those are only available when you use the Splines as shown below</p>"},{"location":"face/brows/#brow-splines","title":"Brow Splines","text":"<p>If you want a spline rig with a ton of ctrls, use the browSplinesSurface() function. On the brows the control set is different to the control set you get with blendShapes.</p>      Your browser does not support the video tag."},{"location":"face/brows/#brow-splines-blueprints","title":"Brow Splines - Blueprints","text":"<p>And those joints are sliding along the two nurbs surfaces surface_forehead and surface_forehead_eyeSocket  Most joints are sliding along the surface_forhead surface but the ones below the main line are sliding along the surface_forehead_eyeSocket To create those surfaces, first click the button Import Default Surfaces and shape them.    </p> <p>Tip</p> <p>To get them shaped as good as possible to the forhead, the easiest thing might be to shape it roughly and then create a shrinkWrap with option closest to snap it to the head geo. Then select vertices and click the button Create Left Brow Curve. You adjust the curve after, the cvs of that curve don't necessarily need to be on the vertices of the skin mesh.  </p> <p>Then click Create Left Brow Orientation Locators and orient those locators. Make sure to have their up axis go along the lines of the surfaces, otherwise you might get the feeling the joints are moving a slightly different location: </p>"},{"location":"face/brows/#brow-splines-fverticalsplineoffsets","title":"Brow Splines - fVerticalSplineOffsets","text":"<p>fVerticalSplineOffsets is the attribute that defines the exra rows. It's a list of all the rows. Negative is below the main brows, and positive is above. If you want those extra rows, you can try with  [-0.05, 0.1] Adjusting the speed of those is done with passer attributes.  </p>"},{"location":"face/brows/#brow-splines-skincluster","title":"Brow Splines - skinCluster","text":"<p>For skinning them, just select the mesh and click the button Add Influences to Selected. This just adds the influences! Then you can paint them with the SkinCluster -&gt; Flood tool. Also, you can use the SkinCluster -&gt; Smooth tool, but try to keep the iterations at 1! </p> <p>Tip</p> <p>If later you change the joint count or blueprint positions, you can also fix the skinning with the Flood tool, but turn on the Distribute Weights option</p> <p>This did NOT do the middle brows yet. Because it's best to just work on the skinning of the main brows first. And only add the Middle one if you actually need it.</p>"},{"location":"face/brows/#brow-splines-middle","title":"Brow Splines - Middle","text":"<p>The middle brow ctrl should be on by default, but if not, turn on bMiddle And it comes with 2 joints:</p> <ul> <li>jnt_m_browMiddleDefault: Just following the side ctrls</li> <li>jnt_m_browMiddle: like the default one, but also reacting to the browMiddle_ctrl</li> </ul> <p>On the actual browMiddle_ctrl you can set how much he should follow the side ctrls. And on the passer you have some extra attributes that you can use to \"sculpt\" a crease with skinning when the side brows are coming in. Sometimes you get a nicely lightweight crease. But depending on the model, sometimes it's easier to just do the crease with corrective blendShapes.</p> <p>Note</p> <p>Don't forget to save those values with the ** === DEFAULT ATTRS === ** button</p>"},{"location":"face/brows/#brow-splines-extra-attributes","title":"Brow Splines - Extra Attributes","text":"<p>Once you have a rough skinning pass, it's time to adjust the Passer Attributes. On the Passer of browMain_l_ctrl you've got multiplyIn/Out/Down/Up, those are to finetune the movements when for example the brows shouldn't go down as much as they should go up. Even though thoes are on the main ctrl, the  micro ctrls (browSplines[ABC]_l_ctrl) will also get affected by this  </p> <p>The passers of the three micro ctrls (browSplines[ABC]_l_ctrl) have</p> <ul> <li>offsetSplineRotateByAnim: When rotating the micro ctrls, should the offset splines also get that rotation?</li> <li>autoAim: should the micro ctrls aim to each others or not</li> <li>upVectorFromCurveTangent: if it's 1.0, the joints are aiming along the curve. For the outer ones you might want to set it to 0</li> </ul>"},{"location":"face/brows/#brow-splines-poselocs","title":"Brow Splines - PoseLocs","text":"<p>There are 2 sets of locators.</p>"},{"location":"face/brows/#micro-ctrls","title":"Micro Ctrls","text":"<p>Those are driven by the browMain_l_ctrl, and are posing the Micro Ctrls (browSplines[ABC]_l_ctrl):  Very often they are just used for the down motion and just the middle, to have the brow  straighten as the browMain_l_ctrl goes down:  </p>"},{"location":"face/brows/#tangent-ctrls","title":"Tangent Ctrls","text":"<p>With those you can pose the Tangent Ctrls: </p> <p>Tip</p> <p>At this point it's very helpful to apply the Rom Animation by clicking the button Create Rom Animation</p>"},{"location":"face/brows/#brow-splines-correctives","title":"Brow Splines - Correctives","text":"<p>If you get stuck not being able to hit a proper shapes with combination of skinning and poseLocators, there's still the  option of adding correctives. <pre><code>browSplinesSplitCtrlsUp\nbrowSplinesSplitCtrlsDown\nbrowSplinesInA\nbrowSplinesInWrinklesA (same as browSplinesInA, but an additional wrinkle attribute will turn it on)\nbrowSplinesUpA\nbrowSplinesUpB\nbrowSplinesUpC\nbrowSplinesDownA\nbrowSplinesDownB\nbrowSplinesDownC\nbrowSplinesSplitJointsUp (experimental - heavy!)\nbrowSplinesSplitJointsDown (experimental - heavy!)\n</code></pre> The ones starting with browSplinesSplitCtrls are probably the most used ones. Their pose is the browMain_[lr]_ctrl  going up or down. And then in the blendShapesAndSliders() function they will get split into the micro ctrls.</p> <p>Tip</p> <p>Keep in mind you are not limited to those. You can create combo of them, and even combo with others.    And if it's still not enough, you can add extra correctives with the ddCorrectives attribute in blendShapesAndSliders() function.</p>"},{"location":"face/brows/#trouble-shooting","title":"Trouble Shooting","text":""},{"location":"face/brows/#for-browssplinessurface-the-brows-are-moving-in-a-different-direction-than-the-ctrls","title":"for BrowsSplinesSurface the brows are moving in a different direction than the ctrls","text":"<p>The brows are moving in straight lines of the surface. At this time the best is to adjust the orientation of the ctrls so  they are oriented to the lines of the surfaces. (There could be a fix in future to support ctrls going more diagonal)</p>"},{"location":"face/eyes/","title":"Eyes","text":""},{"location":"face/eyes/#eye-puppet-limbs","title":"Eye Puppet Limbs","text":"<p>For the eyeballs you have 3 specific limbs:</p> <ul> <li>Eye</li> <li>EyesLookat</li> <li>EyeLookatIndiv</li> </ul> <p>Usually those are already setup-ed when you copied from another character. If you do need to set them up yourself, make sure to specify the eyes in attacher: eyes (c)  EyeLookatIndiv is for when you have some character that has the eyes pointing sideways. In those situations the EyesLookAt is not so great, since the main ctrl is at the front of the character.</p> <p>Once you've got the right setup in there, all you need to do is place the blueprints. And make sure that the polevector in the BP Rig is pointing downwards. Otherwise you'll get troubles later with the eyelid behavior.</p>"},{"location":"face/eyes/#iris-and-pupil","title":"Iris and Pupil","text":"<p>The EyesLookat limb also comes with IrisScale and PupilScale attributes. They reason why they  are on the EyesLookat limb is because those have the ctrls for scaling them:  scaleX/scaleY for Iris, and scaleZ for Pupil.  And make sure to skin the jnt_l_eyeIris and jnt_l_eyePupil joints!</p>"},{"location":"face/eyes/#eyelids","title":"Eyelids","text":"<p>If you didn't add the facePro python file, add it now (facePro_v18.py at the time of this writing). </p>"},{"location":"face/eyes/#basic-ctrls","title":"Basic Ctrls","text":"<p>The function baseLidCtrls() just creates those three arrow ctrls. Those are being used for all setup, no matter if simple lid joints, blendShapes or splines. </p> <p>To get a good rom, apply rom_eyes.anim, which you'll find in almost every character at Export -&gt; Anim Now the eyelids are not moving yet. For them to move, you'll hvae to either do simpleLidSetup() (Simple Lid Joints) or splineLidSetup() (Eyelid Splines)</p>"},{"location":"face/eyes/#simple-lid-joints","title":"Simple Lid Joints","text":""},{"location":"face/eyes/#create-and-skin","title":"Create and Skin","text":"<p>If you turn on the function simpleLidSetup(), you'll get mainly 2 joints for each eye jnt_l_eyeBlinkBot and jnt_l_eyeBlinkTop and a few pose groups that define in which poses the joints should be as you move the arrow ctrls created  in Basic Ctrls</p> <p>After you've run that function, skin the joints.  Don't worry if it doesn't look good yet on the blink, for that you'll need to set the slibling transforms.</p>"},{"location":"face/eyes/#sibling-transforms","title":"Sibling Transforms","text":"<p>those Transforms that you can move around.  Those are working with a similar concept as the  poseLocators you see in lots of other functions. They basically  just define the poses of the joints in all eyelid posed by the arrow ctrls (blink, wide, upperLidUp, upperLidDown, ...) Locate them by clicking the button Select Sibling Transforms And then just place them, as you go through the rom that you applied: </p> <p>Tip</p> <p>Some animators want to be able to achieve a blink by adjusting upperlid and lowerlid separate. In this case you can click the button set extras from blink, which will assign the values from the sibling transforms of the blink onto the lower and upper ones.</p> <p>Many times you can get perfectly looking blinks using a acombination of good skinning and well placed Sibling Transforms. But it's not always the case. In some cases you'll hit limits where you have to add blendShapes on top.</p>"},{"location":"face/eyes/#eyelid-blendshapes","title":"Eyelid BlendShapes","text":"<p>The blendShapesAndSliders() function is using the blendShapes mentioned below.   </p> <p>blink_l_ctrl is triggering the following blendShapes: <pre><code>blink\neyeWide\nupCurveBlink (for some cartoony characters, creates **upCurveBlink** attribute on the blink_l_ctrl)\n</code></pre></p> <p>lidBot_l_ctrl and lidTop_l_ctrl are triggering the following ones: <pre><code>eyeUpperUp\neyeUpperDown\neyeLowerUp\neyeLowerDown\n</code></pre></p> <p>Tip</p> <p>Those blendShapes also work well as correctives on top of Simple Lid Joints (simpleLidSetup()). Because if you just do blendShapes, a blink might be too linear and even giving intersections with the eyeballs.  But getting the spherical motion from the joints and blendShape just as a corrective is giving you the top quality.    And yes, instead of joints you could solve the intersections by adding inbetweens, but the result is often not  as clean.</p> <p>When the eyeballs are looking into different directions, those blendshapes are being triggered: <pre><code>eyelookUp\neyelookDown\neyelookLeft\neyelookRight\n</code></pre> Those eyelook shapes can also be tweaked by animation with the eyesLookAt_l_ctrl.lidFollow attribute.</p>"},{"location":"face/eyes/#eyelid-splines","title":"Eyelid Splines","text":"Your browser does not support the video tag.  <p>The function splineLidSetup() is creating splines that take care of a proper blink using some additional joints. You'll see there's quite a few chapters just for the Eyelid Splines, but 90 % of the time just the first sections  are required. And actually sometimes it doesn't take more than 5 minutes to get nice Eyelid Spline Setup.   But in some cases where you need to go more detail, you have the tools for it.</p>"},{"location":"face/eyes/#eyelid-splines-creating-the-blueprints","title":"Eyelid Splines - Creating the Blueprints","text":"<p>This function needs some extra blueprints, but they are easy to create. Select a vertex along the edge of the eyelids:  Then click the button Create Left Curve and Locators, which creates this curve and two locators:  Those locators need to be at the inner and outer corners. Those are basically what cuts the lid into lower lid  and upper lid. Always check if the locators are placed properly, the tool doesn't always do that correctly. Also notice how there's a hole in the curve, in this case at the upper right side? That's fine,  because this curve is not being used for the setup, it's only to indicate where the actual setup curve should be  when building.  </p>"},{"location":"face/eyes/#eyelid-splines-skincluster","title":"Eyelid Splines - SkinCluster","text":"<p>Next thing is run  until loadDeformers(). Theoretically you could also Run All, but it's not needed.  </p> <p>Note</p> <p>Remember the Selection Templates from the builder? This is where they come in handy ;-)  </p> <p>Select the mesh, and click ==BIND== -&gt; bind to joints on selected mesh     Under the hood this is using the Closest Expand skinCluster tool.  And then test it using the Blink Ctrl.    If you find that the skinning needs more influence, you can adjust the iBindRows. By default it's [2,3] - those numbers represent the FullLoops and FadeOutLoops. For more information what those are, check the ClosestExpand tool. After changing those values you need to bind again using the ==BIND== button.  Might be good to transfer back to the jnt_m_headMain first, also using the ==BIND== button.  </p>"},{"location":"face/eyes/#eyelid-splines-check-the-ctrls","title":"Eyelid Splines - Check the Ctrls","text":"<p>First check the blink_l_ctrl. That ctrl was created in the previous BASELidCtrls() function already, but the splineLidSetup() enabled the rotateZ attribute.  The light blue ctrls are manipulating the spline directly. If you don't like the influence, you can play around with iCtrlSmoothIterations. Whenever you modify this value, you'll need to rebuild to see the results. In some cases adjusting the iCtrlSmoothIterations is enough. But for even more precision you can also directly adjust the weights on the skinCluster skinCluster__curve_l_topCombined__CTRLS of the curve_l_topCombined curve.  Make sure you export the weights of those curves. Btw, when you use Export -&gt; Deformers on those curves, you'll notice he  exports all three skinClusters. You could theoretically delete the 2 unchanged ones, but they don't cause many issues, so I wouldn't bother. </p>"},{"location":"face/eyes/#eyelid-splines-zipper","title":"Eyelid Splines - Zipper","text":"<p>The splineLidSetup() function also comes with a bZipper attribute.  Is it useful?? Animators are very divided on this, feel free to checkout this LinkedIn discussion or even put your opinion out there: LinkedIn Post on EyelidZipper</p>"},{"location":"face/eyes/#eyelid-splines-passer-values","title":"Eyelid Splines - Passer Values","text":"<p>On the passer of the blink_l_ctrl you can find those attributes. Close the eyelid and experiment with them.   Mirroring and Saving those happens with the ** === DEFAULT ATTRS === ** button  </p> <p>Tip</p> <p>if you select the blink_l_ctrl, the shelf button selPssr will select the passer group.</p>"},{"location":"face/eyes/#eyelid-splines-poses-with-locators","title":"Eyelid Splines - Poses with Locators","text":"<p>You'll see a locator for each light blue cube ctrl called for example _poseLoc__eyeSplineBotA_l__blink When the eyelid is in a blink state, just move around the locator to adjust the pose a bit.  It's a great way to make sure the lid is fully closed in case the passer attribute overShootOnBlinkFactor is not enough. Those locators are basically just get activated when blink_l_ctrl.ty is -1.0.  </p> <p>If you want to get more in detail with poseLocators, you can also go to any pose using the blink_l_ctrl or the other  two arrow ctrls, and click Generate PoseLoc at Current LidPosition.    This creates extra locators that you can modify.   </p> <p>Saving locator positions happens with the fill PoseLocs button</p> <p>Saving the PoseLocs works with the Fill PoseLocs button. If you want to get rid of some of the extra poseLocs, don't delete them directly, since this would break the setup. Instead adjust the ddPoses attribute (make sure  to use the JSON Editor!) and rebuild.</p> <p>Warning</p> <p>Very often we create the additional pose on the pose where the upper eyelid is fully down, using the lidTop_l_ctrl. If you set this ctrl pose to NOT be fully down, in the end it will fade back to default when the ctrl is fully down. Which can be unwanted behavior. </p>"},{"location":"face/eyes/#extra-control-on-lids-open-widely","title":"extra control on lids open widely","text":"<p>Once you run the eyelid spline function, you'll get those extra curves:  Those just specify how the lids behave when they get opened wider.  If you want to finetune those, you'll more likely want to set the bLipsCanPushOut value to True, otherwise the lips will always be constraint onto the eyeballs</p>"},{"location":"face/eyes/#eyelid-splines-blendshape-correctives","title":"Eyelid Splines - BlendShape Correctives","text":"<p>If the PoseLocs are not enough, you can also go more in detail with sculpting shapes. For that the Shape Editor needs to be understood. When you are using the Shape Editor, many times doing the usual blendShapes mentioned above like blink are already  enough. But you can go move into detail: You could create a splineLidCorrective* target, that works with a similar timing as the PoseLocs mentioned above.     The names of the newly generated target might sound a little technical. That's just because it's trying to fit a lot of  information into the target name. Basically it's having the lowerlid position and upperlid position in  percentage separated by X. And if there's an n before a number, it means the number is negative. \"splineLidCorrectiveX030X\" = lower lid 30 % up, nothing is after the second X therefore no pose for upper lid \"splineLidCorrectiveX010X089\" = lower lid is 10 % up and upperlid is 89 % down.  If you have 2 poses (lower and upper), then it's spliting those in the blendShapesAndSliders() function, using the skinCluster weights.</p> <p>Tip</p> <p>The lower lid up as shown in the gif above is actually very common.  Often we add that shape but keep it unchanged, just to create a combo with the squint.</p>"},{"location":"face/eyes/#eye-lattice-ctrls","title":"Eye Lattice Ctrls","text":"<p> Just turn on the eyeLatticeCtrls() function and specify the eyeBall geos (sLeftMeshes, sRightMeshes), and the mesh that has the eyelid geos (sSkinMeshes).   After building, you'll have to fix the eyelid weights. It's best done with Weightmaps -&gt; Flood and the Replace Absolute option.  And you are done. In many cases you might want to adjust the ctrl shapes a bit so they aren't buried inside the mesh.</p>"},{"location":"face/eyes/#tweakers","title":"Tweakers","text":"<p>If you don't have spline rig for the eyelids, animators might ask for extra ctrls since the blue arrows are not enough. See TWEAKER_lids() how to add them</p>"},{"location":"face/eyes/#blink-line","title":"Blink Line","text":"<p>There's an attribute on the blink_l_ctrl that can changes the blink when the eyes are closed. Sounds simple - but it needs to be understood how it works under the hood since that's different in all these setups. 1. If you have just blendShapes, that blink line will not do anything. 2. If you have simpleLidSetup() with the siblingTransforms, the blinkLine will rotate the eyelids up/down. Can be useful for small adjustments, but probably unstable if animators move it too much 3. for Spline Rig it works much smoother</p>"},{"location":"face/faceGeneral/","title":"General","text":"<p>Face Rigging in Kangaroo has gotten very powerful in version 5. It's got many different setups to choose from for each part - mouth, brows, eyelids, etc and it's got some general squash/stretch ctrls.</p> <p>Most of the time you have the option of doing spline setups or blendShapes. You can also mix.</p> <p>The first thing to do when you do Face Rig is add the python file facePro_v18.py (right click on the Python Files in the builder -&gt; Add File -&gt; +default -&gt; facePro -&gt; facePro_v18.py</p>"},{"location":"face/faceGeneral/#puppet-limbs","title":"Puppet Limbs","text":"<p>For things like Tongue (Spine), teeth (SingleTransform or Belt) we can use the puppet limbs that we also use for the body. You can also use Tweaker Ctrls if you want to give animators some extra modifiers. But make sure to first read through Face Tweaker Ctrls in here, since those might already give you better options for many cases.  </p>"},{"location":"face/faceGeneral/#blendshapes-vs-splines","title":"BlendShapes vs Splines","text":"<p>Most parts of the face (mouth, eyes, ..) come with two options - BlendShapes and Splines. There are pros and cons to both approaches. Which one you choose depends on a lot of factors, not only the type of character.</p> <p>But generally, use blendShapes if..</p> <ul> <li>you are doing a realistic character, or</li> <li>you have a model team that has the capacity to sculpt blendShapes (not every modeler can model blendShapes!)</li> </ul> <p>Use Spline rigs, if..</p> <ul> <li>you have talented riggers (setting up splines requires technical and artistic skills)</li> <li>you feel that blendShapes would appear a bit to static since they are just turning on/off shapes</li> </ul> <p>Keep in mind that you can always use the blendShapes on top of the splines as correctives! </p>"},{"location":"face/faceGeneral/#blendshapesandsliders","title":"blendShapesAndSliders()","text":"<p>For setting up blendShape Ctrls you need to sculpt the shapes with the Shape Editor. And make sure that the blendShape file you create with the Shape Editor gets imported and baked in the importBlendShapeFile() function. Then blendShapesAndSliders() is the function that takes all those baked target meshes and assigns them as blendShapes.  </p> <p>It's probably the most complex function inside the whole Kangaroo tool. It knows about a huge list of shapes, and can even do some additional shapes defined in the  attributes ddTargetsAsAttributes, ddExtraTargetSliders and ddCorrectives.  It does all this: </p> <ul> <li>inverts some against the skinCluster</li> <li>splits the targets (mostly left/right, but also others like lip ctrls, brow spline ctrls and upper/lower eyelids)</li> <li>creates and connects all the Combo Targets   </li> <li>creates many slider ctrls  </li> </ul> <p>Below you can find an overview of what Targets it accepts.   </p>"},{"location":"face/faceGeneral/#eyes-brows-and-mouth","title":"Eyes, Brows and Mouth","text":"<p>For eyelids and mouth the ctrls are pretty much the same when you use the blendShape setup or spline setup. Therefore you can use the same blendShapes targets. The only difference is that for the spline rig those blendShape targets act more like correctives: Eyelids Mouth  For the brows the ctrls are different between the blendShape setup and spline setup. That's why we have different sets of targets: Brows (BlendShape Setup) Brows (Splines Setup) </p>"},{"location":"face/faceGeneral/#some-more","title":"Some more..","text":"<pre><code>squint\ncheekRaiser\ncheekIn\ncheekOut\npuffFront\nmentalis\nchinRaiser\nlipStretch\nneckStretch\n</code></pre>"},{"location":"face/faceGeneral/#define-your-own-targets","title":"Define your own Targets","text":"<p>But likely you'll hit a point where you want to add a target that you can't find in any of the list. For that case we have 3 extra attributes on the blendShapesAndSliders() function: ddTargetsAsAttributes, ddExtraTargetSliders and ddCorrectives.</p> <p>Note</p> <p>Before reading those, make sure you know about the JSON Editor, since adjusting those attributes directly would be a nightmare!</p> <p>Note</p> <p>This section doesn't explain how to sculpt the targets, it only shows how to specify them in the builder function. For more info about actually sculpting them, check the Shape Editor</p>"},{"location":"face/faceGeneral/#ddtargetsasattributes","title":"ddTargetsAsAttributes","text":"<p>See how we have some extra phoneme attributes F, O and U on an already existing ctrl?  You can create as many as you like, define pretty much any ctrls that is there. And if you define a left ctrl, it automatically splits the shape and puts it onto the left/right ctrls using the fSplitRadius.  </p> <p>Under sTarget you specify be the name that you define in the Shape Editor (O in the picture above).  As the attribute goes to 1.0, the target will be activated. You can also add sTargetNeg, which then would get activated as the attribute goes to -1.0.</p>"},{"location":"face/faceGeneral/#ddextratargetsliders","title":"ddExtraTargetSliders","text":"<p>With the ddExtraTargetSliders attribute you can create new slider ctrls, like this one:  We've specified it as bMirror=False, and only added the sTargetUp and sTargetDown shapes:  </p> <p>Here's another one, where we've set bMirror=True, and also assigned the sTargetIn: </p> <p>Info</p> <p>You'll see that the blendShapesAndSliders() function creates all the ctrl positions, orientations and scale by guessing based on the direction and distance of the targets. But very often you'll want to adjust that. And it's easy - all explained in the following chapter SliderBlueprints. </p>"},{"location":"face/faceGeneral/#ddcorrectives","title":"ddCorrectives","text":"<p>The ddCorrectives attribute lets you specify some corrective targets. Here the target names are the keys on the left of the JSON Editor (CornerDownRotateUp, upperLipUp, upperLipIn):  In the picture above we just specified some ctrls that are already coming from the face. But it doesn't have to be from the face functions. It can also be a ctrl from the puppet. Here we created a corrective for when the trunk was down. We actually left the main target (trunkDown) as the default, but added Combos.    Check the Shape Editor for how to add shape from the rig.</p>"},{"location":"face/faceGeneral/#sliderblueprints","title":"SliderBlueprints","text":"<p>Slider Blueprints are NOT the blueprints in the puppet tool. Instead they are just some simple joints for the Face Setups. There's no centralized place where you manage them. Instead every  function just creates them and puts them into the __sliderBlueprints group. and when you export them, you export them all together. </p>"},{"location":"face/faceGeneral/#mirror","title":"Mirror","text":"<p>While you could theoretically mirror them with the mirror shelf button, usually we mirror them by just not exporting the  right side ones, and then the functions create them using the left side ones. To specify which ones get exported and which ones not you can switch the doExport attribute on each sliderBlueprint joint</p>"},{"location":"face/faceGeneral/#export","title":"Export","text":"<p>Exporting works with the button -export *Slider* BPs-. You'll find this button on many functions such as BASELidCtrls(), blendShapesAndSliders(), parallelAttachTransforms(). And it'll do the same thing on each function, it exports ALL the sliderBlueprints, not just the ones of the current function.</p>"},{"location":"face/faceGeneral/#placing-them","title":"Placing them","text":"<p>Kangaroo tries to estimate the position/orientation/scale according to the actual blendShapes. This doesn't always look good by default, so you have the option to adjust it manually. Most of the time it's best to build until before parallelAttachTransforms(), and then adjust their locations and scale. This way you can test right away if they work well with the blendShape they are driving.  </p>      Your browser does not support the video tag.  <p>Unfortunately whenever they are driving spline rigs such as the lips spline rig, the live connection from the sliderBlueprints already gets broken in the function where they are created. In those cases you just have to guess when giving them good scale values, and rebuild.</p>"},{"location":"face/faceGeneral/#defaultattrs","title":"DEFAULT ATTRS","text":"<p>On many functions you'll see that === DEFAULT ATTRS === button. It's attributes that are usually on the passers of the  ctrls that can be used to finetune the setup.  </p> <p>But sometimes also pose locators. </p> <p>The button lets you mainly Mirror or Fill the attributes. Filling means putting their values into the functino attribute. </p> <p>Watch Out</p> <p>While it often does pose locators, it's not always the case. Check if that function has an extra button for filling  the Pose Locator. Or if still unclear, click the Info or Select option in the Default Attrs menu.</p> <p>Kangaroo Tool Tip</p> <p>If you want to update values after you've filled them, the The JSON Editor can help you with this. </p> <p>Python</p> <p>This Default Attrs button with so many menus is actually relatively easy to script in case you want to create a similar button for your own tools. Just check out the Python section</p>"},{"location":"face/faceGeneral/#deformer-order","title":"Deformer Order","text":"<p>The order how deformers are applied to the meshes is very important. The functions to add influences that you find on all the setup functions usually take care of it, but there's many things that can reshuffle the order in a bad way. So you'll have to check here and there if the order is still correct: <pre><code>skinCluster__head_geo__BENDTOP\nskinCluster__head_geo__BEND\nlattice__head_geo__r_EYE\nlattice__head_geo__l_EYE\nskinCluster__head_geo__TWEAKER\nskinCluster__head_geo\nblendShape__head_geo\n</code></pre> Basically blendShape first, then the main skincluster (the one without a suffix), __TWEAKERS, eye lattices, __BEND and in the end __BENDTOP. This is assuming the head geo is called head_geo, so in your case those deformers might be called different. You might also not have all of them, or you might have some extra ones. </p>"},{"location":"face/faceGeneral/#jaw","title":"Jaw","text":"<p>In the simplest form, the jaw ctrl is just a singleBone limb. Make sure that the blueprints look like this, basically the polevector is pointing  downwards, and don't use any Adjust Axis Orient values. </p>"},{"location":"face/faceGeneral/#auto-translate","title":"Auto Translate","text":""},{"location":"face/faceGeneral/#from-shape-editor","title":"From Shape Editor","text":"<p>If you use the Shape Editor, make sure to keep fOverwriteRotation and fOverwriteTranslation in the  jawAutoTranslate() function as None, since those values should be coming from the shape Editor. And then see Shape Editor - Getting Jaw from the Rig to see how to setup that in the Shape Editor. The extra rotations (X, Y) and all translations are fully activated on the Z rotation that you've specified in the * button.</p>"},{"location":"face/faceGeneral/#without-shape-editor","title":"Without Shape Editor","text":"<p>If you don't use the Shape Editor, you can set the jaw with the attributes in the image below. Similar to the  Shape Editor setup - The extra rotations (X, Y) and all translations are fully activated on the Z rotation  (3rd number in OverwriteRotation)</p> <p> </p> <p>Warning</p> <p>Don't forget to set those values to None if you are getting the jawOpen values from the Shape Editor! If you have some values in there and they are different than what's in the Shape Editor, things can get messy.</p>"},{"location":"face/faceGeneral/#jawopen-blendshape-pose","title":"jawOpen blendShape Pose","text":"<p>By default the jawOpen blendShape target is NOT getting activated at the same timing of the Auto Translate.    </p> <p>Check in this table to see at which value the jawOpen is getting activated:  </p> Current Functions/Attributes rotateZ value he's using for jawOpen BASEMouthCtrls() active with bSPLINES as True jawOpen entry in the dPoseCtrlValues BASEMouthCtrls() active with bSPLINES as False Auto Translate (either Shape Editor or override values) BASEMouthCtrls() NOT active Auto Translate (either Shape Editor or override values) <p>So in short - when you doing Mouth splines, it's taking from the dPoseCtrlValues, and it can be an issue that it's  different timing than the Auto Translate! Therefore when you are doing splines, it's recommended to set the jawOpen in dPoseCtrlValues to the same as the rotateZ that you have in the Shape Editor * button or override value.</p> <p>Why does it not just take the jawOpen rotateZ for mouth splines from the ShapeEditor or override values?</p> <p>That's because when doing mouth splines, the BASEMouthCtrls() function is also creating locator setup. And it's more important that the jawOpen is following the locator setup than following the RotateZ value</p>"},{"location":"face/faceGeneral/#troubleshooting-why-is-the-pose-rig-button-in-the-shape-editor-not-going-to-the-correct-pose","title":"Troubleshooting: Why is the Pose Rig Button in the Shape Editor not going to the correct pose?","text":"<p>Mouth splines: There's a little gotcha: If you change the jawOpen in the dPoseCtrlValues, you need to rebuild and reference the rig again.  This is some sort of exception, since for most other targets the Pose Rig buttons will take the values directly from the builder.</p> <p>No Mouth Splines: You also need to rebuild/rereference the rig, even if you change the values in the * button of the Shape Editor!</p>"},{"location":"face/faceGeneral/#troubleshooting-why-does-the-jaw-rotate-sideways-if-i-rotate-it-upwards","title":"Troubleshooting: Why does the jaw rotate sideways if I rotate it upwards?","text":"<p>This is a little issue that happens here and there, but here's the fix: It's most likely happening because it\u2019s getting the motion from the joints in the blendShape file, and in there the jaw joint is at the origin. Either delete the joints in the blendShape file, or set them properly by getting Skin Setup from the rig. Or you just disable the jawAutoTranslate function, you may not always need it.</p>"},{"location":"face/faceTweakerCtrls/","title":"Face Tweaker Ctrls","text":""},{"location":"face/faceTweakerCtrls/#what-are-they","title":"What are they?","text":"<p>Tweaker Ctrls are some extra ctrls on top of your setup that animators can use to add some secondary behavior.</p> <p>Info</p> <p>Remember Tweaker Ctrls in Puppet? The Tweaker ctrls we are talking about here work with the same logic, and most things here you could theoretically recreate with what you've learned in Tweaker Ctrls before. But the functions here are  engineered a bit more specifically for facial rigging purposes.</p> <p>Apart from the sockets we usually just use those tweakers on blendShape driven setups. If you are already using spline setups such as splineLidSetup(), browSplinesSurface() or the bSPLINE mode of BASEMouthCtrls(),  most of the tweaker setups won't be that useful since those spline setups already come with a lot of ctrls.</p>"},{"location":"face/faceTweakerCtrls/#the-functions","title":"The Functions...","text":""},{"location":"face/faceTweakerCtrls/#tweaker_lids","title":"TWEAKER_lids()","text":"<p>Those are for eyelids. Great for when you have blendShape driven Eyelids, and you just want to give animators some extra control on top of those.  First specify the skin mesh under sAttachmesh. This is so later the parallelAttachFunction() knows where to attach the passers to.</p> <p>To create the blueprints - select the vertex loop selected:   Click the button Create Left Curve and Locators. That gives you this curve with locators.   Make sure the locators are at the corners, since those are what separates bottom and top lids.  </p> <p>And then click -Export Eyelid Tweaker BPs - </p>"},{"location":"face/faceTweakerCtrls/#tweaker_sockets","title":"TWEAKER_sockets()","text":"<p> That's the eye sockets. On cartoony characters animators almost always expect them to have some extra control when brows move down. Creating the blueprints and exporting works the same as in TWEAKER_lids</p>"},{"location":"face/faceTweakerCtrls/#tweaker_browssimple","title":"TWEAKER_browsSimple()","text":"<p>Nothing fancy, just 3 controls per side:    Creating the blueprints and exporting works the same as in TWEAKER_lids You do have some extra BPs for the brows to specify the orientations with Create Left Brow Orientation Locators: </p>"},{"location":"face/faceTweakerCtrls/#tweaker_lips","title":"TWEAKER_lips()","text":"<p> Creating the blueprints starts (!) the same as in TWEAKER_lids, But then you need to specify the bFlipInnerBpCurves attribute. Set it to True if in the center cvs the upper  one is below the lower one.  </p> <p>Tip</p> <p>If you made a mistake with the bFlipInnerBpCurves and you need to swich that attributes after you've already skinned it, you can fix the weights with distribute option on either the Flood or the ClosestExpand tool. For both select the whole mesh. For the ClosestExpand tool also set the loop attributes very high, so you let the fade out be handled by the mask of the previous weights.</p> <p>And the lips come with another option - the bSplines attribute. If you leave it to False,  it works just as the other functions. But setting it to True means he's running a joint spline through the vertices/ctrls. The result is much nicer in 90 % of the cases. But it is somewhat heavier because the spline is following the previous deformers etc.</p>"},{"location":"face/faceTweakerCtrls/#skincluster","title":"SkinCluster","text":""},{"location":"face/faceTweakerCtrls/#easy-ones-first","title":"Easy ones first..","text":"<p>All of these TWEAKER_..() functions come with a button called Add Influences to Selected. And then you can use the Flood tool to bind those vertices. Just set the Choose Skin Cluster to __TWEAKER, reload the list, enter the type of tweakers in the search field (lids, lips, etc), select the joints, put in a nice vertex selection -&gt; Flood  On characters with lower resolution, also put the Smooth Steps to 1.  </p> <p>Tip</p> <p>For painting the sockets, close the eyelids and maybe even set the blink line to 0.5, (and reactivate the soft selection), so the flood tool grabs a nicer area. Similar goes for the lips - open the mouth, this will give make the  flood tool assign the weights better.</p> <p>Warning</p> <p>Do not use the maya tools or any other external tools for creating the skinClusters! That's because for the tweakers the skinCluster needs extra settings under the hood. Those would not happen with any tool that is not from Kangaroo.</p> <p>Tip</p> <p>The Flood tool can also be very useful with the Distribute option activated. For example if you already flooded the weights, but it's too smooth - run it with distribute  but in the same tool also set the Smooth Steps lower.</p>"},{"location":"face/faceTweakerCtrls/#skinning-tweaker-lips-splines","title":"Skinning Tweaker Lips Splines","text":"<p>If you've set the bSplines attribute to False, most of it is the same as in the other setups tools. </p> <p>But if you bSplines as True, then instead of the Flood tool, you should use the SkinCluster -&gt; ClosestExpand tool  for binding them. Why?  Because we have a joint for each vertex on the loop.   </p>"},{"location":"face/faceTweakerCtrls/#ctrl-attachments","title":"Ctrl Attachments","text":""},{"location":"face/faceTweakerCtrls/#parallelattachtransforms","title":"parallelAttachTransforms()","text":"<p>Same as for Custom Attachers, the parallAttachTransforms() function is making the ctrl passers follow the mesh. It's called parallel because it seems like it's getting attached to the mesh, but in fact it's looking at which joints the closest vertex of each ctrl is bound to, and then recreates the skincluster behavior of that vertex with matrix nodes. It works for more than one skinCluster, but does NOT include the actual __TWEAKER skinCluster that those ctrls are influencing. Otherwise you'd get a cycle. It's similar for blendShapes, except instead of matrix nodes it's using range nodes.  </p>"},{"location":"face/faceTweakerCtrls/#what-if-a-ctrl-doesnt-follow-nicely","title":"What if a ctrl doesn't follow nicely?","text":"<p>In some rare cases it doesn't find a good vertex. You'll see that when for example on open mouth or closing eyelids  one or two ctrls are following a bit too slow or too fast.</p> <p>Whenever that happens, the first thing is check if your function has the bSnapToBlueprintCvs attribute. If it does, try setting that to True.</p> <p>If that doesn't help - we can fix it with a python function that's moving the passer groups closer to the actual vertex you'd like to bind to:</p> <pre><code>@builderTools.addToBuild(iOrder=85.5, dButtons={})\ndef adjustmentsForParallelTransforms():\n    cmds.setAttr('grp_l_tweakerLipsTopPasser_003.t', 3.356, 49.845, 8.152)\n    for s,sSide in enumerate('lr'):\n\n        cmds.setAttr(f'grp_m_tweakerLipsBotPasser_000.t', 0.0, 49.769, 12.009)\n        cmds.setAttr(f'grp_m_tweakerLipsTopPasser_000.t', 0.0, 49.747, 12.267)\n\n        fSideMultipl = -1.0 if sSide == 'r' else 1.0\n        cmds.setAttr(f'grp_{sSide}_tweakerLipsBotPasser_002.t', fSideMultipl*2.72, 49.79, 9.59)\n        cmds.setAttr(f'grp_{sSide}_tweakerLipsTopPasser_002.t', fSideMultipl*2.653, 49.817, 9.665)\n</code></pre> <p>Note</p> <p>See the iOrder=85.5 flag in addToBuild decorator? This is to make sure the function runs between the TWEAKER_*() functions and parallAttachTransforms()</p>"},{"location":"face/faceTweakerCtrls/#using-the-lips-tweakers-more-than-once","title":"Using the Lips Tweakers more than once","text":"<p>The TWEAKER_lips() function can be added more than once on the same character. It works in a way that the second one follows the first one with an additional skinCluster. Setting it up is a bit more advanced:</p> <ul> <li>right click on TWEAKER_lips() -&gt; set function instance count -&gt; 2 (or more)</li> <li>on the second function that just appeared: set the sSuffix attribute to something like 'A', otherwise you'll end up having clashing names </li> <li>And for the second function you also have to add the first skincluster (.._TWEAKER) into the sAdditionalAttachDeformers() list, so it also follows the first one</li> </ul>"},{"location":"face/mouth/","title":"Mouth","text":"<p>For lips you also have option between blendShapes and splines. But what's different to the other setups is that on the lips you do both ways with the same function: BASEMouthCtrls()</p>"},{"location":"face/mouth/#blueprints","title":"Blueprints","text":"<p>The first part of the blueprints is the same between blendShapes and Splines</p>"},{"location":"face/mouth/#blueprints-inner-and-outer-curves","title":"Blueprints - Inner and Outer Curves","text":"<p>First select the closest (or smallest) loop of vertices, and press Create Inner Curves and Locators  This gives you this blueprint curve with locators. Make sure the locators are at the outer corners, since those are separating the top and the bottom.  Now there's a very important and easy to miss attribute - bFlipInnerMouthCurves. On many characters the lips are so close together, that in the middle the upper vertices are lower than the lower vertices. If this is the case, then you'll need to set that attribute to True. Otherwise False.   </p> <p>Don't forget!</p> <p>Make sure to doublecheck the bFlipInnerMouthCurves, you might not notice it's wrong until the very end.</p> <p>And then select the loop of the outer corner of the lips, and press Create Outer Curves and Locators </p>"},{"location":"face/mouth/#blueprints-mouth-pivot","title":"Blueprints - Mouth Pivot","text":"<p>Then click Create Mouth Pivot. Imagine if the mouth moves left/right in a sperical motion, where should the center be? That's where you place the bp_m_mouthPivot</p> <p>It's important that the X axis is pointing up, Y axis is pointing back, and the Z axis is pointing to the right. Why is not not closer to worldspace? That's because it's closer to how the head joint is.   </p> <p>Watch out</p> <p>If when translating the mouth_ctrl up/down/left/right things are moving in wrong directions, check the orientation of this blueprint.  If the lip ctrls are not translating up/down in Y, it could also be the fault of this mouth pivot blueprint.     </p>"},{"location":"face/mouth/#blueprints-slide-surfaces","title":"Blueprints - Slide Surfaces","text":"<p>This is only for spline rigs. If you leave the bSPLINE attribute as False, you can skip this.  But for splines, this is the surface that the controls slide along. In most cases this is better to represent the shape of the teeth, instead of the shape of the skin. For now just shape it roughly, but very likely you'll be revisiting this later and adjust the shape.  </p> <p>Watch Out</p> <p>Make sure that this spans from almost the symmetry line to as far back as the lip ctrls should go, and ideally a bit further. If the lip ctrls or the corner ctrls are doing some very bad jumps or generally some unstable motions,  this surface is often not placed well.</p>"},{"location":"face/mouth/#upper-and-lower-ctrls","title":"Upper and Lower Ctrls","text":""},{"location":"face/mouth/#count-and-position","title":"Count and Position","text":"<p>The Lip Ctrls (Upper and Lower Lips Ctrls) are the only dynamic ones, where you can specify how many you'd like. And you do that with the fLeftLipParamPercs. Now thats's a bit technical and needs to be understood. If you set the attribute to [0.20, 0.33, 0.5], you'll get this many lip ctrls: Is it too many? Yes, for a human most likely. But for dogs thave have long mouths, this could be the right amount. For humans you might want to set it to [0.33, 0.5], which means one in the middle (yellow) and one on each side. Or if you don't want the middle, just set it to [0.33]</p> <p>Note</p> <p>You see how we don't specify parameters after 0.5? That's because as the name already says it, we only specify  the left ones, and the right ones are mirrored. </p>"},{"location":"face/mouth/#orientation","title":"Orientation","text":"<p>The orientation of those ctrls happens with the slider blueprints (sliderBp_l_lipsBot1, sliderBp_l_lipsBot0, ..).  But unlike the other (simpler) slider blueprints, the ones for the lips are not live! So you have to adjust before running the BASEMouthCtrls(), export those and rebuild.</p>"},{"location":"face/mouth/#blendshapes","title":"BlendShapes","text":"<p>Here you can see a list of blendShapes. Those can all be used with or without the bSPLINES attribute. If you set bSPLINES to True, then the blendShapes will act as correctives.  </p> <p>Corners (lipsCorner_[lr]_ctrl): <pre><code>    cornerIn\n    cornerOut\n    cornerUp\n    cornerDown\n    cornerOutUp (diagonal)\n    cornerOutDown (diagonal)\n    cornerInUp (diagonal)\n    cornerInDown (diagonal)\n</code></pre> If you are using the diagonal ones, you need to set bbCornerBarycentricCoords in blendShapesAndSliders() to True.     </p> <p>Note</p> <p>For simple rigs you'll likely get away with just the simple ones (cornerIn, cornerOuot, cornerUp, cornerDown).  Or use the simple ones and add combos, such as cornerOut_cornerUp instead of cornerOutUp. But for more high fidelity rigs you'll definitely get better blending between the poses if you use the diagonal ones.</p> <p>Upper/Lower Lips (lipsTop[0-9]_[lr]_ctrl): <pre><code>    upperUp (upper lip raiser)\n    upperDown (opposite of upperUp)\n    lowerDown (lower lip depressor)\n    lowerUp (opposite of lowerDown)\n</code></pre></p> <p>mouth_ctrl: <pre><code>    funnel\n    lipPress\n    mouthLeft\n    mouthRight\n    mouthUp\n    mouthDown\n</code></pre></p> <p>Box Ctrls Translations (mouthBot_ctrl, mouthTop_ctrl): <pre><code>    funnelBot\n    funnelTop\n    lipPressBot\n    lipPressTop    \n</code></pre></p> <p>Box Ctrls Rotations: <pre><code>    lowerRollIn\n    lowerRollOut\n    upperRollIn\n    upperRollOut\n</code></pre></p> <p>Note</p> <p>For realistic humans it would be best to shape the funnel and lipPress according to their scientific representation  (one page to check about FACs is facial-action-coding-system). But if you are doing cartoony characters, many times animators prefer Box Ctrls and mouth_ctrl to just simply move the lips forward or back. </p>"},{"location":"face/mouth/#rom","title":"Rom","text":"<p>At this point it's good to check out the Rom - by clicking the button Create Rom Animation. </p>"},{"location":"face/mouth/#mouth-directions","title":"Mouth Directions","text":"<p>If you move the mouth_ctrl up/down/left/right or rotate it in rotateZ, (Frame 75-135 in the ROM), you can do this with the  mouthLeft/mouthRight/mouthUp/mouthDown blendShapes (except the rotateZ).   But you can also do that with skinning. Select the area around the mouth, open the Face Skinning UI and click Move Jaw/Head to frontPivots</p> <p>Remember the mouth pivot blueprint? It's rotating the mouth along that pivot. But if you don't like the motion, there's not always the need to go back and adjust the blueprint - instead you can just adjust the passer values.  On the passer of mouth_ctrl, you can find those values you can adjust:  </p> <p>Tip</p> <p>If you feel like you want to do the mouth directions entirely with blendShapes because you are concerned that the joint movements are just working against you, just set all those attributes to 0.0. Or if you also don't need the rotateZ, you can ignore this setup by just not skinning the joints.</p>"},{"location":"face/mouth/#splines","title":"Splines","text":"<p>Splines are using the same controls like the blendShapes. This brings a few advantages:</p> <ul> <li>You can use all the blendShapes stated above also as correctives</li> <li>You can have some characters with blendShapes and some with splines, and animators will have the same sets of controls</li> </ul> <p>You'll get the splines when you set bSPLINE to True. And also set bBorders to False. The borders are useful for blendShapes, but not for Splines.</p>"},{"location":"face/mouth/#spline-the-joints","title":"Spline - The Joints","text":"<p>For the spline rig there are the Big Joints (jnt_l_botMouthSplineBig_???) and the Small Joints (jnt_l_botMouthSplineSmall_???).  By default they are a joint at each vertex on the loop. But if you have a character that has a ton of joints, then you can set the iSkipSplineJoints value to something higher than 0. For example if you set it to 1, it means it skips every other joint. If you set it to 2, it always skips 2 joints until the next one. Why are they called Big and Small Joints? That's becuase the bigger ones are bigger, .. But also because the bigger ones have (should have) a wider range of influence. Basically the Small Joints should just affect the lips  since they are taking more rotation from the ctrls. The Big Joints take less rotational movements from the Ctrls, and therefore are more stable to use for the area around the lips.     </p> <p>There's 2 more special joints, which are jnt_l_lipsEnd and jnt_r_lipsEnd. Those sit at the corner, and it's best to bind the area left and right of the lips. Basically part of the cheekcs</p>"},{"location":"face/mouth/#splines-skinning","title":"Splines - Skinning","text":"<p>At this point before skinning the Mouth Spline Joints, it helps a lot if the jaw is already skinned nicely. But don't worry -  if you do want to adjust the jaw weighting later, there's nice buttons that transfer skinning from spline joints to jaw/head and back.</p> <p>Note</p> <p>While you are free to use your own skinning tools on the mouth splines, it's recommended that you follow this workflow, since it involves tools that are made specifically for this setup.  </p> <p>To get the Mouth Spline Skinning tools, click this shelf button:  Which brings up this UI:  </p>"},{"location":"face/mouth/#big-joints","title":"Big Joints","text":"<p>The best thing is to just start with the button Add to Big Joints when you have the whole head selected.  But first set the Rigid Loops and Fade Loops values. It's using the ClosestExpand SkinCluster tool under the hood, therefore it's best to check that for reference.</p> <p>Tip</p> <p>Make sure to use the Grow Selection (CTRL &gt;) and Shrink Selection (CTRL &lt;) Maya commands and Soft Selection!</p> <p>At this point it's best to load the Rom Animation</p> <p>Now you can do a few combinations of:  </p> <ul> <li>clicking the Add to Big Joints on different vertex selections</li> <li>smoothing with just one iteration (there's a Smooth button at the bottom of the UI)</li> <li>add some weights to the lipsEnd Joints using the Move head/jaw to LipsEnds button</li> </ul> <p>Warning</p> <p>You might be tempted to use the smooth tool a lot. But please don't overdo this. And if you use the smooth in the skinning tools, make sure to NEVER do more than one iteration when it's about the face. Unless it's a very high resolution face.</p> <p>At this point try to get it to look clean, but don't worry too much about the details yet. That part comes later.</p>"},{"location":"face/mouth/#small-joints","title":"Small Joints","text":"<p>Did you notice that at this point in the Rom between 60 and 75 it's just rotating the box ctrls, but nothing is happening? That's because the small joints are handling the lip rolls. Select the vertices of just the lips (or the whole face and lower the Rigid/Fade Loops), and click Add To Small Joints. To see the results, check the roll movements a bit later in the Rom that you applied before.</p>"},{"location":"face/mouth/#fixing-weights","title":"Fixing Weights","text":"<p>If your weights got messy because you changed spline joint count (either by adjusting the curves or iSkipSplineJoints flag), or if just used the smooth tool too much - there's a way to fix this.</p> <p>In the FaceSkininng UI, click the \u201cDistribute BigJoints\u201d and \u201cDistribute SmallJoints\u201d buttons.</p> <p>This grabs the current weights of all the joints, and uses that as a mask while redoing the expand weights operation.</p>"},{"location":"face/mouth/#splines-adjust-ctrl-behaviors","title":"Splines - Adjust Ctrl Behaviors","text":"<p>At some point when the skinning looks somewhat clean, it's best to start adjusting the behaviors of the ctrls some more. The following things (1-5) should be done roughly in the same order, but most likely you'll be jumping back and forward, and even might adjust skinCluster here and there.  The goal is to get the shapes and behaviors looking as good as possible without adding blendShapes (even though you can still add corrective blendShapes on top - the better the underlining setup, the more smooth the rig will be) </p>"},{"location":"face/mouth/#1-slider-blueprints","title":"1. Slider Blueprints","text":"<p>Especially for the corners ctrls, try to find the right blueprint scale to get the best overall possible range.  </p> <p>Note</p> <p>Unfortunately the slider blueprints don't affect the ctrls live. So you'll have to guess (or calculate) the scale, and rerun the BASEMouthCtrls() function.</p>"},{"location":"face/mouth/#2-corner-multiply-values","title":"2. Corner Multiply Values","text":"<p>The corner multiply values specify how much the joints should move based on the corner ctrl movements. They should be used only in cases that scaling the slider blueprints couldn't solve. Such as if the cornerOut should be stronger than the cornerIn </p>"},{"location":"face/mouth/#3-defining-a-different-corner-range","title":"3. Defining a different Corner Range","text":"<p>So far the poses happen on a unified range, where corner ctrls only go to 1.0s or -1.0s. But in some cases (especially cornerOut ones) you might  want to specify for example the ctrl corner_l_ctrl.tx to be 2.5. </p> <p>This can be done with the ddPoseCtrlValues attribute. And it will affect Pose Locators, BlendShape Poses and even the Create Rom Animation button.</p> <p>Warning</p> <p>While the kangaroo tools such as pose editor support this, it can be cleaner to stay in a unified range. Therefor it's best to try to solve things with  Slider Blueprints and Corner Multiply Values first. </p>"},{"location":"face/mouth/#4-lip-ctrl-passer-values","title":"4. Lip Ctrl Passer Values","text":"<p>The lips attributes come with a few passer attributes that specify how the lip ctrls should react to the neighboring ones, and to the corner ctrls: </p>"},{"location":"face/mouth/#5-pose-locators","title":"5. Pose Locators","text":"<p>Almost all ctrls come with lots of poseLocators that are used to define the ctrl behaviors even more. In funnel and lipPress they are even used to define the whole pose. And all the pose locators are easily found by just selecting the ctrls, and in the outliner press f. You'll always see the the currently activated one as shown and the others are invisible: </p> <p>Tip</p> <p>There's a lot of poseLocators in the BASEMouthCtrls() function, even for each detail ctrls. If you end up using them a lot, it's worth checking out the options under the button ** -- PoseLoc Tools -- ** </p>"},{"location":"face/mouth/#adjusting-pivots-for-lip-rolls","title":"Adjusting Pivots for Lip Rolls","text":"<p>In some characters you might be struggling with getting proper lip rolls because they pivot around the joints while ideally they should pivot around the center of the lips. But there's a solution - you can change the pivot using the offset groups ending with Pivot: </p> <p>Adjusting those will move the joints, so it's best to turn off the skinCluster. And show the curve with mouth_ctrl.curveVis.</p> <p>Then you save their values with the **=== Default Attr === ** button, and rebuild. You should be able to get nicer Lip Rolls now.</p> <p>Warning</p> <p>This will mess with the zipper! So if you are adjusting the pivot groups, it's best to set bZipper to False* and use the  postZipper() function if needed</p>"},{"location":"face/mouth/#nlf-setup","title":"NLF Setup","text":"<p>NLF stands for Nasolabial Fold, and it's that line between the nose wing and the mouth corners. Some characters have it more prominent than others. But the hardest ones to rig are those where you don't see the line in the model, but it's expected on the smile - such as many female characters. In any case the createNlfSetup() can be very useful for keeping that line stable. But this function only works if you have createBASEMouth() with bSLINE attribute enabled. </p> <p>You can adjust how many ctrls you want, in the picture above it's the default - 2 at the top (fTopCtrlPercs) and one at the bottom (fBotCtrlPercs) </p> <p>Each ctrl comes with extra attributes to adjust the behavior, and they all come a Pose Locator Setup driven by the Corner Poses.</p>"},{"location":"face/mouth/#cheek-setup","title":"Cheek Setup","text":"<p>The setup is very similar to NLF lines, except that those lines are a bit further outside. And it's used mainly to enhance the smile a bit more by bulging out the cheeks </p> <p>Note</p> <p>This function is optional. Since it requires more technical abilities to manage so many joints, some projects in the past opted for blendShape NLF lines instead of this. </p>"},{"location":"face/mouth/#post-lip-zipper","title":"Post Lip Zipper","text":"<p>If you are not using spline (or you are using spline but offsetted the pivot groups), then the only way to do a zipper is the postZipper() function. This creates another skinCluster with the __ZIPPER suffix.</p>"},{"location":"face/shapeEditor1/","title":"Shape Editor I","text":"<p>The Shape Editor is a tool for modeling Facial Shapes (targets).  </p> <p>Video</p> <p>To see how the Shape Editor looks in action, you can also watch this Video. But keep in mind that some menu options changed since the time of making that video.</p> <p>You can open the Shape Editor with the shelf button  </p> <p>  On the left side of the UI you see all the Main Targets. And on the right side you see the Combo Targets.</p>"},{"location":"face/shapeEditor1/#its-not-the-pose-editor","title":"It's NOT the Pose Editor!","text":"<p>You might find a few similarities to the Pose Editor, but the architecture and how we use it is quite different:   </p> <ul> <li>The Pose Editor runs on the actual rig, but the Shape Editor runs on another file that gets imported in the importBlendShapeFile() and gets applied to the rig in the function blendShapesAndSliders()</li> <li>While the Pose Editor focuses on how shapes are driven and can add shapes on its own, the Shape Editor mainly (apart from combos) is just about sculpting and managing the shapes.</li> </ul>"},{"location":"face/shapeEditor1/#getting-started","title":"Getting Started","text":"<p>You can select any polygon mesh, and click the &lt;&lt; button:    If that polygon mesh wasn't used with the Shape Editor yet, it'll ask you to choose a Target List.  By default you just have cartoon and general. If you are creating a blendShape rig where you want to do most  shapes including mouth, eyes, etc with blendShapes - choose general. But if you are doing a rig where you want do do most tarets with splines, then cartoon is a better start, because it only lists the targets that doesn't  have spline rigs.  </p> <p>What did he do under the hood? He created a new blendShape node. And all the Targets that you see in the UI are basically blendShape Targets on  the blendShape, just like you've already used before:   </p> <p>Kangaroo Tool Tip</p> <p>While in the gif above I just selected vertices and moved them, you can do a lot more. For example you can use the sculpting tools (Mesh Tools -&gt; Sculpting Tools) or use some Kangaroo Geometry Tools such as the Match or Smooth Vertices tools.</p> <p>Note</p> <p>You are not limited to just general or cartoon! Later in Adding More Main Targets you'll see how to either create your own custom lists or just add targets to your existing collection. </p> <p>Now to sculpt some main targets by clicking the Edit button and sculpt:  </p> <p>Note</p> <p>Here we have a similarity to the Pose Editor but also a difference. While in the Pose Editor you also have those EDIT buttons that you use to sculpt the Targets, in the Pose Editor you have to select the meshes, while in the Shape Editor it just does it on all the meshes that are in the collection. </p>"},{"location":"face/shapeEditor1/#combos","title":"Combos","text":""},{"location":"face/shapeEditor1/#combos-create-them","title":"Combos - Create Them","text":"<p>Combo targets is the Table on the right side. You can create any combination between 2, 3, 4, ... Main Targets. Most of the time we create combination of just 2 targets. Sometimes 3, and very rarely 4.  For a combination of 2 targets the combo would be called for example cornerUp_upperUp. A combination of 3 would be cornerUp_noseWrinkler_upperUp. It's basically the main targets' names ordered alphabetically and separated by a single _.</p> <p>Note</p> <p>You will never have to name them yourself, the tool takes care of it. You just need to be aware that whenever you create a Main Target yourself, it cannot have the _ sign in there.</p> <p>Creating them is easy, just select the main targets, right click -&gt; create combo Targets: </p>"},{"location":"face/shapeEditor1/#combos-multiplyminimum","title":"Combos - Multiply/Minimum","text":"<p>In the gif above you can see that in the end we switch between the evaluation modes Muliply and Minimum. Multiply means that the main targets are just multiplied. So if cornerUp is activated 0.8 and upperUp is activated 0.5, the combination will be 0.4 (0.8 * 0.5). And in Minimum in the same example it would be 0.5, because 0.5 is the smaller one between 0.8 and 0.5.  </p> <p>Both modes have pros and cons. If you use Multiply, the result will be smoother but the issue is that the shape will not  be driven linearly while all main targets are being activated the same time. For example if you have 2 main targets that are both  activated as 0.5, the combo target will be 0.25. But ideally it should also be 0.5. Look at this example where we have a combination of 3 Main Targets. See how it moves slower at smaller values, and then speeds up at higher values?  </p> <p>If you need it to run linearly, you can switch to Minimum. If all main targets are 0.5, the combo target would be 0.5, too. But Minimum has the ugly disadvantage that it's not as smooth as Multiply. In certain situations you'll find that as one main target is being  activated slowly, the combo might suddenly change from getting activated to not reacting. Look at this example. See how it moves more linear, but if I move one alone it starts activating at one point? Animators hate that!  </p> <p>Warning</p> <p>The disadvantages of both modes (Multiply and Minimum) are only getting worse the more Main Targets you use for the  combo. So keep it to a minimum! Any combination of more than 3 targets can get very nasty.</p>"},{"location":"face/shapeEditor1/#combos-add-percentage","title":"Combos - add Percentage","text":"<p>When you open the blendShapes.ma on the THOMAS asset, you'll see a combo called jawOpen50_mouthClose. This just means that the jawOpen will only go to 0.5 (50 %):  </p>      Your browser does not support the video tag.  <p>Try it out! But don't overuse them. The art of sculpting shapes is making this work with the simplest logics. But if you do need the extra complexity, it's there. Changing and adding percentages happens through the marking menu: </p>"},{"location":"face/shapeEditor1/#extra-sliders","title":"Extra Sliders","text":"<p>At the bottom you see a lot of sliders. Those are just representations of how the rig will later set them up. So they are basically a great way to get a feeling of how they will work later.  On each slider you could also isolate the targets with the right click menu, so you can see what targets are driven by them.  Open the Shape Editor File from the templates asset THOMAS, and play around with the sliders:  </p>      Your browser does not support the video tag."},{"location":"face/shapeEditor1/#mirror","title":"Mirror","text":"<p>Mirroring contains 2 parts. Creating Mirror Table, and actually Mirroring</p>"},{"location":"face/shapeEditor1/#mirror-table","title":"Mirror Table","text":"<p>Right click on the mesh in the Mesh Table at the bottom right:   You can choose between:</p> <ul> <li>middle mesh, edgeflow: maping vertices through the middle edge algorithm</li> <li>middle mesh, vertex positions, mapping through vertex positions</li> <li>middle mesh, face points: finds point on face, and does barycentric mapping</li> <li>side meshes, ids: needs 2 meshes with same vertex orders </li> <li>side meshes, vertex positions: needs 2 meshes, maps by vertex positions</li> <li>side meshes, face points, needs 2 meshes, maps by point on face and barycentric coordinates</li> </ul>"},{"location":"face/shapeEditor1/#actually-mirroring","title":"Actually Mirroring","text":"<p>Mirroring also works on vertex selection. But you do need to right click on the actual mesh for the mirror.  </p> <p>Don't Forget</p> <p>Do not forget to select the mesh in scene! Sometimes we assume that when we right click on the actual mesh in the UI it would do the mesh. But from the power of being able to select vertices comes the responsibility to also select the mesh in scene.</p>"},{"location":"face/shapeEditor1/#inbetweens","title":"Inbetweens","text":"<p>You can add inbetweens to any Target.  </p>"},{"location":"face/shapeEditor1/#interpolate","title":"Interpolate","text":"<p>Inbetweens are basically another shape stored in the node. It may not appear like this at first because when you apply the  inbetween, it gives it a default shape which is the interpolated shape at the time of when you apply it. BUT if you change the Full Target, the inbetween will NOT change. But there's a solution to it - you can re-interpolate the inbetweens. You'll loose the shape that you sculpted on the inbetween, but it'll follow again that the full shape does. You'll see the options on the right click menu:   </p> <p>Note</p> <p>You'll see the words All Inbetweens and Closest Inbetwween a lot in the Shape Editor. It's relevant when you  have more than one inbetween. So in the picture above where there are 3 inbetweens (red marks) the current weight is closer to the first one, therefore the Closest Inbetween would only touch the first one. </p> <p>Watch Out</p> <p>When the blendShapesAndSliders() adds the blendShapes, the logic of inbetweens is a bit complicated because of a few mathematical challenges on how those inbetweens work. This means in certain situations you might find things behaving a bit strange.  It's recommended to keep inbetweens to minimum. And if you do use them, watch out for the results carefully.</p>"},{"location":"face/shapeEditor1/#meshes","title":"Meshes","text":""},{"location":"face/shapeEditor1/#addsecondarymeshes","title":"Meshes - Add Secondary Meshes","text":"<p>Easy, just select them and add them with the right click menu:  </p> <p>Kangaroo Tool Tip</p> <p>By default they are just sitting there and not following the main skin. But you can make it follow the skin with the Tools explained below.</p>"},{"location":"face/shapeEditor1/#meshesmainmesh","title":"Meshes - Main Mesh","text":"<p>It's important to keep the Main Mesh (skin in this example) as the main mesh. It's usually always the case, unless you start replacing a few meshes. But it's easily fixed with right click menu: </p>"},{"location":"face/shapeEditor1/#meshesmodelchange","title":"Meshes - Model Change","text":""},{"location":"face/shapeEditor1/#same-topology","title":"same topology","text":"<p>If the model changed in topology, it's easy. Just select the new mesh, and then with right click on the mesh that you want to change -&gt; Model Change from \"xxx\" to \"xxx\" </p>"},{"location":"face/shapeEditor1/#different-topology","title":"different topology","text":"<p>If the overall shape is still the same and modeling just changed the topology a bit, it's a bit of a manual process, but it's not difficult: 1. rename the old mesh 2. restart the shape editor 3. add the new mesh (with correct name!) 4. warp the new mesh to the old mesh  5. if the old mesh was the main mesh: set it as Main Mesh  6. check the lips on open targets! Targets like jawOpen. upperUp or lowerDown can get screwed on warp. If they  are screwed, either fix them manually or try the Warp UVs</p>"},{"location":"face/shapeEditor1/#different-topology-and-different-shape","title":"different topology and different shape","text":"<p>If the topology is different AND the shape is entirely different, we are basically talking about making a new character. Check Transfer to New Character further below.</p>"},{"location":"face/shapeEditor2/","title":"Shape Editor II","text":""},{"location":"face/shapeEditor2/#connecting-the-rig","title":"Connecting the Rig","text":"<p>There's two main reason why we need to connect the rig into the blendShape Editor - getting jawOpen/eyeLook joints into the Shape Editor, and getting certain poses into the Shape Editor so we can sculpt correctives.</p>"},{"location":"face/shapeEditor2/#loading-the-rig","title":"Loading the Rig","text":"<p>For both things you have to start by referencing the rig, using the reference rig button at the top of the Kangaroo UI.</p> <p>Note</p> <p>If you are getting the rig with the reference rig button, you have to build/publish the rig before. If you don't want  to publish, you can also hold scene where you've built the rig, and then with the right click menu of the pull scene you can reference the rig in. More info on hold/pull</p> <p>Then just hide the top group of the rig, you won't have to directly do anything in it unless you are trying to debug something. Then having anything from it selected, click the &lt;&lt; button at the very bottom.  </p>"},{"location":"face/shapeEditor2/#getting-jaw-from-the-rig","title":"Getting Jaw from the Rig","text":"<p>The benefit from having the jaw joint in the Shape Editor is that you can sculpt the jaw shape and also specify how  the jaw joint should behave. Having those 2 things in different places would make it difficult to polish the deformations.  </p> <p>To get the joints and skinning, select all the meshes and click the most bottom button Get Skin Setup. You should end up with joints that look like this:  The skin weights are also taken from the rig, but it went through a few numpy operations to group the weights of the non-existing  joints to either jnt_m_headMain or jnt_m_jawMain.</p> <p>Note</p> <p>If after clicking the Get Skin Setup the joints don't look like in the image above, delete the current joints you have and try again.  Sometimes if you have some joints in there already he tries to use them which may not always be helpful.  </p> <p>Try to activate the jawOpen target. It might look like this:    You may have to fix some skinning, especially if you also added the teeth (which we didn't do in this case). But more important, you'll have to fix the jaw motion. See how currently it's just rotating? Let's make it so it also translates it a bit, and at the same time even make the rotation a bit less. This is happening with the * button next to the jawOpen. That opens this UI, where you can adjust the rotateZ, and add some translation values: </p> <p>Trick how to find the proper Jaw Values</p> <p>You probably just got a headache from those values because you don't know what space they should be, or how to even enter without seeing the result right away!  But don't worry, there's a trick:</p> <ol> <li>Select the jaw joint, break the connections and then translate/rotate the jaw joint into a good place: </li> <li>Make a screenshot of the values on the jnt_m_jawMain (or write those values down)</li> <li>Click the * button, enter the values in there. And when you click save, it'll restore the connections again  </li> </ol> <p>Note</p> <p>The values in the * button will also make it into the rig! Just make sure you have the jawAutoTranslate() function activated  without any overrides in the attributes. It will work in a way that as the animator rotates the jaw_ctrl.rotateZ  to what you have defined as rotateZ, it'll also translate the jaw ctrl the same way as the joint is being translated from the values you entered.</p>"},{"location":"face/shapeEditor2/#getting-eye-look-from-the-rig","title":"Getting Eye Look from the rig","text":"<p>It all works the same as the jaw, but it's a little simpler because we are not sending back/forward values. Just make sure the eyeballs are skinned to the eye joints, and the targets that have the extra are eyelookUp, eyelookDown, eyelooLeft, eyelookRight. And if you are a skilled modeler, you can create some nice eyelook targets:  </p>"},{"location":"face/shapeEditor2/#grab-targets-for-corrective-sculpting","title":"Grab targets for corrective sculpting","text":"<p>Especially for cartoony rig we want to use the Shape Editor to sculpt some correctives. Select any target and some mesh (full mesh or vertex/soft selection), and click the button Pose Rig and Match Mesh/Vertex Selection.  But before that with the BS Off* or BS On* buttons you should specify if you want to get the targets with or without  the already applied blendShapes.  </p> <p>Note</p> <p>To know which target you need to specify here for which corrective, check  blendShapesAndSliders(). You might even want to  define your own targets for that.</p>"},{"location":"face/shapeEditor2/#tools","title":"TOOLS","text":"<p>The Shape Editor comes with a lot of tools, and you won't use it efficiently unless you know about all the tools.   For every tool in there, select the Targets and the Mesh! And for the mesh selection you can also select vertices and soft selection. </p>"},{"location":"face/shapeEditor2/#tools-multiply","title":"TOOLS - Multiply","text":"<p>The Multiply tool is probably the simplest but most important one. Ever had an animator tell you Please make all shapes 1.5 as strong as they are currently? Well, that's easy with the Multiply tool:    But it doesn't stop there! Use the tool to multiply by a value smaller than 1.0 (like 0.35 or 0.8) if you want to lessen the effect on a shape in certain regions. Or even multiply by 0.0 to erase some small moving vertices. Or multiply negative like -1.0 if you want to make a shape go the reverse direction! Just below the Multiply in the marking menu you have the Multiply in Y. Seems a bit arbitrary because it only does it in Y, but we use it a lot for some tricks on the brow shapes.</p>"},{"location":"face/shapeEditor2/#makemeshesfollow","title":"TOOLS - Make Meshes Follow","text":"<p>There are 3 types of tools you need to choose from depending on the situation: Warp, Warp Rigid and Warp Wire.  </p> <p>Video</p> <p>We'll explain all the objects right below. But you can also watch it in the video from here (Secondary Meshes).</p>"},{"location":"face/shapeEditor2/#warp","title":"Warp","text":"<p>If you set the main skin as the Master, the warp will just make meshes follow, and it's using the wrap deformer under the hood:    </p>"},{"location":"face/shapeEditor2/#warp-rigid","title":"Warp Rigid","text":"<p>In the picture above you see that the cubes around the mouth are changing their shapes. To solve that we have the Warp Rigid. This one analyzes all the islands of the mesh separately and makes sure their shape doesn't change: </p>"},{"location":"face/shapeEditor2/#blend-ids","title":"Blend Ids","text":"<p>This is if you want a target to have exactly the shape from another mesh</p>"},{"location":"face/shapeEditor2/#warp-uvs","title":"Warp UVs","text":"<p>Warp UVs has similar results as Warp. But - if the uvs between the meshes are the same - it might do a better  job on the lips. But other areas might not be as nice as the wrap.</p> <p>Tip</p> <p>Always try the Warp first. Try the Warp UVs only if the Warp is giving you issues that are hard to fix.</p>"},{"location":"face/shapeEditor2/#warp-wire","title":"Warp Wire","text":"<p>The Warp Wire tool is used for eyelashes. The previous warp tools don't work well for eyelashes since they work  with closest point logic. And with eyelashes usually sticking out so far the results aren't just working without a lot of cleanups. So the Warp Wire is under the hood using the Wire Deformer to move the meshes by a curve.   You just have a create the curve with the Curve from selected vertices button in the Extras tab, and use that curve as the Master: </p>"},{"location":"face/shapeEditor2/#adding-more-main-targets","title":"Adding more Main Targets","text":"<p>There's Predefined Targets and Custom Targets. Both can be added with the right click menu.  </p> <p>Note</p> <p>And this point it would help to have an overview of what targets you can actually add. Check the blendShapesAndSliders() function. </p>"},{"location":"face/shapeEditor2/#predefined-targets","title":"Predefined Targets","text":"<p>Under the Right click menu Add Target you'll see a lot of them:  The ones that you see above the line are defined by the Kangaroo tool. If you add those in there, the blendShapesAndSliders() function will just add, mirror and connect them. The ones below the line (in this image A, B, EE, ..) are the ones that you specified  in the attributes ddTargetsAsAttributes, ddExtraTargetSliders or ddCorrectives of the blendShapesAndSliders() function. </p> <p>Note</p> <p>For those targets to appear in the menu it's important that you have the Kangaroo UI open and switched to the current character. Once you've added the targets, it doesn't matter anymore if the Kangaroo UI is open or not.</p> <p>Info</p> <p>To see how you can set those attributes, check Define your own Targets</p>"},{"location":"face/shapeEditor2/#custom-targets","title":"Custom Targets","text":"<p>Custom targets are targets that you just put into that textfield on the right click menu:  Most likely by putting them in there, they won't do anything in the blendShapesAndSliders() function. Unless you put them into one of the attributes mentioned above.</p>"},{"location":"face/shapeEditor2/#targetlist-file","title":"TargetList File","text":"<p>If you are setting up things for a bigger project with more characters, you'll more likely want to predefine a list of shapes, so artists don't have to add one by one target throught the right click menu. That's what Target lists are for, and you can switch between them in the combo box up there.   </p> <p>Note</p> <p>You can also set them at the beginning when you open the Shape Editor on a mesh the first time! Which is actually more recommended.</p> <p>Create a new empty folder and specify it with the environment variable KANGAROO_TARGETLIST_PATH.</p> <p>Note</p> <p>To get started quickly, you can also do that with the pathsEnv.mel on the root folder of kangaroo installation directory.  </p> <p>In that folder just add a text file with the prefix .targetlist, such as dog.targetlist: dog.targetlist<pre><code>snarl True False\njawOpen True False\nsquint True False\nblink True False\neyeWide True False\nlipStretch True False\nnoseWrinkler True False\nearsBack True False\n</code></pre> The True/False next to the names are all about the checkboxes. If you want the artist to be able to switch on/off,  make the first one True. And if you want that checkbox to be on by default, make the second one True, too.</p> <p>Note</p> <p>To start with the general or cartoon one, grab those files from the installation folder scripts\\kangarooShapeEditor</p> <p>Info</p> <p>Do you want to share the blendShape file with another team, but you don't want to go through the stress of setting up the Environment variable plus targetlist file for them? No problem, they don't need the targetlist file, since it also gets saved locally in the blendShape file.</p>"},{"location":"face/shapeEditor2/#bakefill","title":"Bake/Fill","text":"<p>If you want to sculpt the shapes in an external tool such as ZBrush, that's also doable. For creating meshes from the targets, click Bake under the Extras tab.   Then you can export those, and re-import. To put the shapes of those meshes back into the targets, select them and click the Fill Selected Sculpts to Targets button. </p> <p>Note</p> <p>The Fill Selected Sculpts to Targets button is also useful for other situations, for exapmle when you baked  shapes using another another python script.</p>"},{"location":"face/shapeEditor2/#setting-a-target-from-another-mesh","title":"Setting a target from another Mesh","text":"<p>One way to do that is with the Fill Selected Sculpts to Targets button, if you just make sure that the selected mesh has the correct target name. Another way is through the TOOLS button - Blend Ids</p>"},{"location":"face/shapeEditor2/#workflow-tricks","title":"Workflow Tricks","text":""},{"location":"face/shapeEditor2/#create-an-opposite-target","title":"Create an Opposite Target","text":"<p>For some targets we don't want to do much sculpting, we just want to generate it from negating another one. Best example is the upperDown, or lowerUp. For the upperDown: select upperUp and upperDown together (order matters!), right click Copy Deltas of ... And then use the multiply tool with -1.0:  </p>      Your browser does not support the video tag."},{"location":"face/shapeEditor2/#make-delta-from-current","title":"Make Delta from Current","text":"<p>You can dial in a few targets, and then right click on one, Make Delta from Current puts the current shape into the current target. Look at this example where we use the upperUp target to open the lips slightly on the noseWrinkler:  </p>      Your browser does not support the video tag."},{"location":"face/shapeEditor2/#transfer-to-new-character","title":"Transfer to New Character","text":"<p>Transfering to a new character is more advanced. It requires downloading Wrap3D (https://www.russian3dscanner.com/download/)  and possibly even getting a license.  </p> <p>At the time of writing this documention, you also have to specify the tool location in kangarooShapeEditorUI.py file: <pre><code>kWrap3dExe = 'C:/Program Files/Faceform/Wrap 2023.11.4/WrapCmd.exe'\n</code></pre></p> <p>Once you have that all setup-ed, you'll have to create those relations between the 2 meshes. </p> <p>Video</p> <p>To see how that works in detail, watch this part of the Video</p>"},{"location":"face/squashStretch/","title":"Squash/Stretch","text":"<p>The createBendSetup() function function is creating some general squash/stretch setup. They are two additional skinClusters, suffixed by __BEND and __BENDTOP.</p> <p> </p>"},{"location":"face/squashStretch/#blueprints","title":"Blueprints","text":"<p>When you click Create BPs, he just creates some colored joints that you need to lay out to the shape of the head </p>"},{"location":"face/squashStretch/#ctrl-shapes","title":"Ctrl Shapes","text":"<p>After running the createBendSetup() function, move those ctrl shapes to the right place, just be dragging their cvs:  And of course after that export the ctrls shapes.</p>"},{"location":"face/squashStretch/#weights","title":"Weights","text":"<p>It's very important to create the weights using the Kangaroo tools, because those are setting some important things that other skinning tools won't. These are the joints:  But don't worry you don't actually have to look for them or select them in the scene or outliner. just follow the instructions how to do that with the Flood tool, and you'll be done very fast with this.</p>"},{"location":"face/squashStretch/#using-the-flood-tool","title":"Using the Flood tool","text":"<p>To create the skinClusters, having the main mesh selected start by clicking the buttons connect Influences (selectded Meshes) and  connectInfluences TOP (selected meshes).</p> <p>Then apply the rom animation by clicking the button create rom anim</p> <p>In the Choose Skin Cluster field, specify __BEND, and click the reload button.</p> <p>Bind everything above the neck to the jnt_m_faceBendMiddle. This is the main cube ctrl - frame 0 - 30 </p> <p>Then in the flood tool select the jnt_m_botFaceBendSquash_001 joint and bind the bottom part of the face to it. </p> <p>Note</p> <p>Even though there's more bottom joints, the bottom part usually works better with painted to just one joint.</p> <p>Next, the Choose Skin Cluster field, specify __BENDTOP, and click the reload button. And bind the whole head to all the top influence joints </p>"},{"location":"face/squashStretch/#transfer-from-main-mesh-to-others","title":"Transfer from main mesh to others","text":"<p>This can be easily done with the SkinCluster -&gt; Transfer tool: Set the From to the name of the skinCluster that you created before, and turn  Auto Create New SkinCluster on   </p> <p>Warning</p> <p>Do not forget the Auto Create New SkinCluster otherwise you will damage your existing weights.</p> <p>Note</p> <p>The auto create new skinCluster option doesn't always create new skinCluster. If the skinCluster with the proper suffix (__BEND or __BENDTOP) is already present, he'll use that instead of creating new one</p>"},{"location":"face/squashStretch/#smooth","title":"Smooth","text":"<p>Especially the eyeballs will likely get some sharp corners from the weight transfer. But those are easily fixed with the Smooth tool. Just make sure to enter __BENDTOP (or  __BEND), and click smooth </p>"},{"location":"face/squashStretch/#tweak-it","title":"Tweak it","text":"<p>When you look at the Rom or play around with the ctrls, it's probably not looking perfect yet.  </p> <p>You can adjust the squash/stretch values with the attributes on the passers of the ctrls. Those get saved with the DEFAULT ATTRS button</p> <p>And apart from that you might still need to spend some time tweaking the weights with the Smooth, Flood or Move tool.</p>"},{"location":"face/squashStretch/#only-one-skincluster-option","title":"Only one skinCluster option","text":"<p>You probably saw that by default he added all the bottom joints also into the __BEND skinCluster. If could theoretically solve it all with one skinCluster, but then you'd have to adjust the blueprints so the lower and upper blueprints are not overlapping each other.</p>"},{"location":"face/squashStretch/#ctrls-following","title":"Ctrls Following","text":"<p>Kangaroo tries to have most ctrls follow the squash/streth setup. This won't change the deformations, but animators still appreciate it if ctrls are always staying with the face geo. For all the facial setups this should happen automatically in the function parallelAttachCtrls().   But if you have some extra puppet limbs, you'll have to set this with the FaceExtraMove flag:   Limbs that have it supported are spine, singleTransform, singleBone and belt</p> <p>Note</p> <p>on some limbs that attribute might be a further below:  </p>"},{"location":"puppet/bellCollider/","title":"Bell Collider","text":"<p>The singleBone limb comes with a Bell Collider. Bell Collider looks like dynamics but it's really just interactive angle calculations. It works great for short pants.   While it looks great in the video, it does come with the disadvantage that he can only handle cylinders. But those can be scaled non-uniformly, translated and rotated. And with some multiply attributes you can specify it to be weaker in either front, back or on the sides.</p>"},{"location":"puppet/bellCollider/#setting-it-up","title":"Setting it up","text":"<p>It's quick to setup. Just add a singleBone limb, declare it as a bell with the isBell attribute, and define the ringer in the attacher below. The ringer in this case is another singleBone limb that is  located close to the bell. And the ringer itself doesn't need any extra settings. Actually it doesn't even know that  it's a ringer. We just named it ringer. </p>"},{"location":"puppet/bellCollider/#shaping-the-cylinders","title":"Shaping the Cylinders","text":"<p>Then you need to fine tune the cylinders. Show them with setting master.rigVis to True. Ringer is easy to see, but for the bell, even though you'll see a bell in the scene - the one that you need to adjust is the hidden one right next to it in the outliner. And then translate/rotate/scale the bell and the ringer. Multiply values can be useful, too - but don't overuse them! They are only here to limit the bell in a certain direction. When you are happy with how it works, save the settings in the puppet limb's right click menu Custom: Store Bell Settings </p>"},{"location":"puppet/bellCollider/#trouble-shooting","title":"Trouble shooting","text":"<p>Especially when setting it up the first time, you might find it's not behaving as you want it to. Here's a few common issues and how to solve them:</p> <ol> <li>The bell is flipping as I rotate it to 90 degrees: Might be an easy solve - switch the Bell Up Vector from default of (0,1,0) to (0,0,1)</li> <li>The bell jumps very unnatural as it touches the ringer: Give the bell a blended attacher, that it already moves like the ringer 50 % without the bell setup. </li> </ol>"},{"location":"puppet/dynamics/","title":"Dynamics","text":""},{"location":"puppet/dynamics/#springs","title":"Springs","text":"<p>The following limbs come with a Spring attribute:</p> <ul> <li>singleBone    </li> <li>singleTransform    </li> <li>spine (fk, fkSpline)</li> </ul> <p>They work with a very basic spring equation done with Expressions: <pre><code>Acceleration = (Target - Position) * STIFFNESS - Velocity * DAMPING\nVelocity += Acceleration\n</code></pre> STIFFNESS and DAMPING are the attributes that are exposed and can be tweaked, even by animators.  For tweaking those values, it's best to first keep them the same value, and try variations from 0-1.  STIFFNESS is how fast it comes back (stronger values = coming back quicker) DAMPING is how loose it is (weaker values = looser)  </p>"},{"location":"puppet/dynamics/#spine-dynamics","title":"Spine Dynamics","text":"<p>The Spine limb also has Dynamics attribute in the advanced section, which is using hairSystem under the hood. Can give great results, too. But trickier to tweak the behavior. </p> <p>Tip</p> <p>You can still tweak that behavior, but it's more advanced. You'll have to find the hairSystem node and in there you can find all the attributes. You could even setup collisions for that.</p> <p>Here we attach both end points.   </p>"},{"location":"puppet/limbsReference/","title":"Limbs Reference","text":"<p>This document gives you an overview about all the limbs that are there.</p>"},{"location":"puppet/limbsReference/#singletransformsinglebone","title":"SingleTransform/SingleBone","text":"<p>The most simple limbs are the SingleTransform and SingleBone. They are really just simple one ctrl limbs. Here's a few examples we use them for:  </p> <ul> <li>placement_ctrl (SingleTransform)</li> <li>cog_ctrl (SingleTransform)</li> <li>head_ctrl (SingleBone)</li> <li>jaw_ctrl (SingleBone)</li> </ul> <p>You have a quite a lot of options about how much translation, rotation and scale values you want to expose. And also if you want pivot ctrls or super ctrls.</p>"},{"location":"puppet/limbsReference/#adjustaxisorientation","title":"adjustAxisOrientation","text":"<p>The singleBone has the option of specifying another orientation, in case you want to change the orientation without adjusting the blueprints: First build the rig with adjustAxisOrientation as 0,0,0. Then manually rotate the slider group of the ctrl to how you  want it, and store those values into the adjustAxisOrientation. And then rebuild the rig.</p> <p>Warning</p> <p>Be careful with the Scale options. If this limb has child limbs, it's not good to expose all or some scale axes, since  scaling things non-uniformely will not pass well onto the other child limbs. So whenever you have child limbs, either switch between off or uniform. And if you do need to expose all or some scale axes, make sure that limb doesn't have any child limbs.</p> <p>They also have some more advanced features of singleTransform/singleBone, but those are discussed in other documents:  Bell Collider, Springs, Feature Ctrls </p>"},{"location":"puppet/limbsReference/#spine","title":"Spine","text":"<p>The Spine Limb is probably the most multifunctional limb. While we use it - as the name suggests - we also use it every time we have a simple FK chain.</p> <p>Fk and fkSpline come with some dynamic options. But those are discussed in Dynamics.</p>"},{"location":"puppet/limbsReference/#blueprint-attributes","title":"Blueprint Attributes","text":"<p>There's 2 attributes - the blueprint joint count and the blueprint joint count.  It's best to start with setting them the same value, so you can control where which joint is. But there's 2 situations where you'd want to make the blueprint count lower:  </p> <ul> <li>Your spine joint count is very high (&gt; 8) and you just don't want to take care of so many blueprint joints  </li> <li>You want to quickly add more spine joints without having to go into the blueprints</li> </ul>"},{"location":"puppet/limbsReference/#blueprint-curve","title":"Blueprint Curve","text":"<p>For the blueprints we usually do joints. But the Spine has the option of doing a curve instead of joints. Just switch the Blueprints Curve attribute to on. When you create the blueprint skeleton and the curve  is created, the cv count will be the Blueprint Count. This will give you 2 curves. One for the joint locations, and the other one for the up vectors. </p> <p>Warning</p> <p>Do not neglect the Up Curve! Is this is not laid out around the main curve in a clean way, you'll get twist issues.</p> <p>Tip</p> <p>If you have long cables, don't don't lay out the curves manually since it'd take you a long time. Instead try this trick first: </p>"},{"location":"puppet/limbsReference/#fk","title":"fk","text":"<p>Let's start with the simplest case. Just some completely unfancy fk ctrls. It's actually the default. Just leave all other features (in orange) unchecked, and only  the fk (feature) activated: </p> <p>It gives you those ctrls: </p> <p>Tip</p> <p>For the simple fk, it's recommended to keep blueprint joint count and blueprint joint count as the same number, so you can specify exactly where the joints and ctrls should be. </p>"},{"location":"puppet/limbsReference/#fkspline","title":"fkSpline","text":"<p>Many times we want to have more joints for better deformations, but keep the ctrl count low. Then it would  make sense to switch to fkSpline:   </p>"},{"location":"puppet/limbsReference/#fksplineaddremovectrls","title":"fkSpline - Add Remove Ctrls","text":"<p>Adding/Removing ctrls and changing their locations works with the ctrl percs attribute. To add more you first have to resize the attribute. First thing after that you'll notice that it's just adding 0s at the end. But you can fix that by just right click again and interpolate </p> <p>Note</p> <p>There's always one ctrl at 0.0, which is not shown in the list. So if the list shows 3 ctrls, it's building 4 ctrls because of the additional one at the beginning.</p> <p>Tip</p> <p>Make sure to also try the interpolate, more on end (square) option on the right click menu.  This places more ctrls towards the end. Very often animators want more ctrls towards the tip of  the tongue or tail for example.   </p>"},{"location":"puppet/limbsReference/#fkspline-rev-ctrls","title":"fkSpline - Rev Ctrls","text":"<p>Animators sometimes want this on the torso: </p>"},{"location":"puppet/limbsReference/#fkspline-tweaker-ctrls","title":"fkSpline - Tweaker Ctrls","text":"<p>Note</p> <p>This is NOT Puppet Tweaker Ctrls or Face Tweaker Ctrls. The only common thing it has with those is that it runs on top of another setup.</p> <p>Those ctrls run on top of main ctrls and rev ctrls.   </p> <p>Tip</p> <p>The bottom square ctrl can be used for the hips especially in cartoony characters. But not always!  In many cases it's better to add the hips as a separate singleTransform or singleBone limb at the bottom.  </p>"},{"location":"puppet/limbsReference/#fksplinestretchmode","title":"fkSpline - stretchMode","text":"<p>The stretchMode attribute specifies how the joints should be aligned onto the curve. The options are:  </p> <ul> <li>spline ik</li> <li>curveInfo nodes (soft twist)</li> <li>curveInfo nodes (rigid twist)</li> <li>motionPath nodes (soft twist)</li> <li>motionPath nodes (rigid twist)</li> </ul> <p>Spline ik is using the maya spline ik, which comes with extra minStretch and maxStretch values. This is very important  for realistic creatures where you need to have the torsos keep their lengths: </p> <p>Warning</p> <p>Spline Ik does NOT have stable twist values! When you use that mode, you'll have to turn on the Ctrl Twist in the  Advanced section</p> <p>CurveInfo nodes is using the pointOnCurveInfo nodes, and the motionPath nodes are using the motionPath nodes. CurveInfo nodes is faster and should be used in 95 % of the cases. But motionPath gives better distribution in some cases.  </p> <p>The difference between soft twist and rigid twist is that for soft it's creating a curve for the twisting, while for the rigid twist it's just finding the upvector points by interpolating some offset vectors. Rule of thumb is always use rigid twist first. And if it's giving you weird behavior, try soft twist</p> <p>Note</p> <p>In 99 % of the cases the twisting should be ok with either soft or rigid. If you hit that one percent where the twist is still  behaving strangly, try switching the up axis from [0,1,0] to [0,0,1]</p>"},{"location":"puppet/limbsReference/#fkspline-preik","title":"fkSpline - preIk","text":"<p>PreIk is creating some ctrls that are manipulating the FK Ctrls. </p> <p>Tip</p> <p>This is mainly for speed optimizations on Biped Torsos. The torso in general is a bottle neck because not much can get calculated at the same time. If on Bipeds animators want IK spine, in the past we would have always added ikSpline feature. And it would still be a valid approach,  but creating the preIk spine has better performance since instead of creating extra blendable joint splines it's just manipulating the root ctrls (fkSpline main ctrls). Other bonus you get from this is that animators can still utilize the rev ctrls.</p>"},{"location":"puppet/limbsReference/#ikspline","title":"ikSpline","text":"<p>ikSpline has some similarities to the fkSpline, with the main difference that it's ik  </p> <p>Tip</p> <p>As mentioned above - if you are creating a torso rig, consider just sticking with fkSpline and preIk, since in many cases that would be better for performance. </p>"},{"location":"puppet/limbsReference/#ikspline-addremove-ctrls","title":"ikSpline - add/remove ctrls","text":"<p>Adding/removing and positioning of ctrls is happening with the Ctrl Percs attribute.  You can adjust it the same way as the Ctrl Percs fkSpline</p>"},{"location":"puppet/limbsReference/#ikspline-chest","title":"ikSpline - Chest","text":"<p>If Chest Perc is at 1.0, there's no chest, and the top ctrl is called spineTopIk_ctrl. If you give chest a lower value,  for example 0.8 - the top ctrl is then called spineChestIk_ctrl, and the lower ctrls are compressed between 0 and 0.8: </p>"},{"location":"puppet/limbsReference/#ikspline-stretchmode","title":"ikSpline - stretchMode","text":"<p>stretchMode behaves the same as on fkSplines</p>"},{"location":"puppet/limbsReference/#ikspline-cablesstraps","title":"iKSpline - cables/straps","text":"<p>Very often we use the Spine limb for cables/straps   See the image below for how attributes were set in the gif above:   The green rounded arrow ctrls that you see in the gif above are the Tangent Ctrls.  They are created automatically and just need to be turned on with the visibility attributes on the end ctrls.</p> <p>Other tips on cables/straps:</p> <ul> <li>Very often you'll want to activate the Remove End Ctrls, because you can still use the attachers on them without the ctrls</li> <li>Attach Middles To Line is always activated by default. But often you don't want to have the ctrls follow the outer points.</li> <li>If you want the cables/straps extra smooth, try Auto Tangent as shown next topic</li> </ul>"},{"location":"puppet/limbsReference/#ikspline-auto-tangent","title":"ikSpline - Auto Tangent","text":"<p>Auto Tangent tries to keep the curve smoother by aiming to the ctrls.  </p> <p>Warning</p> <p>This is doing some aiming with automatic polevectors, so it can get unstable in some cases. </p>"},{"location":"puppet/limbsReference/#advanced","title":"Advanced","text":"<p>If you turn on the Advanced checkbox at the bottom, you'll get those extra squash joints:   This give you a few more options:  </p> <ul> <li>adjust the orientation mode (if you used spline Ik as stretch mode)</li> <li>give animators the power to scale the joints with the ctrls</li> <li>add some extra Dynamics that run after the animation </li> <li>distribute the orientations of the joints to behave more stable on fat characters</li> </ul> <p>Most of it should be self explanatory, except distribute orientations deserves a bit more attention.</p>"},{"location":"puppet/limbsReference/#distribute-orientations-for-fat-characters","title":"distribute orientations for fat characters","text":"<p>See how how on the side the cubes of the spine are crashing with each others? It's because the joints are just orientating based on the ctrls around them. And the wider the bellies are in relation to their heights, the stronger the crashing will be. The solution is Distribute Orientations, which assigns a new orientation to those joints that is blending between bottom and top ctrls of the spine: </p> <p>Tip</p> <p>You have two attributes on each squash joint to fine tune that behavior:  For saving those you'll have to do a python function.</p>"},{"location":"puppet/limbsReference/#skinning-the-squash-joints","title":"skinning the squash joints","text":"<p>If you already skinned the character, and you turned on the Advanced checkbox later, you can easily transfer the  skinning to those squash joints by selecting the meshes and right click option: </p> <p>The Kangaroo Skinning Tools (Flood, Move, ..) come with another extra feature that other skinning tools don't give you: Have you ever noticed how generally binding to closest doesn't find the closest point per distance to the actual joint, but instead  to the bone, which is the line between the joint and the child? And you might assume that you won't get that feature here because those squash joints don't have child joints? Well, no - those squash joints have a hidden attribute (\"skinParent\") that make sure that the kangaroo skinning tools treat them as the main joints that have proper child joints.</p> <p>Tip</p> <p>In the advanced section you can also turn on Dynamics. This is explained in the Dynamics section.   But before activating that, it's recommended to try the Spring first!</p>"},{"location":"puppet/limbsReference/#armleg","title":"ArmLeg","text":"<p>We use the same limb for the arms and the legs. On the leg we just switch the Is Leg attribute to on:  This changes mainly the names (for example (elbow -&gt; knee) default blueprints and default rotate orders.</p> <p>Warning</p> <p>It's easy to forget! Because you'll find it's still working, but just later you'll realize that the knee is called elbow..</p>"},{"location":"puppet/limbsReference/#ik","title":"IK","text":""},{"location":"puppet/limbsReference/#worldorientctrlarmlegik","title":"World Orient Ctrl","text":"<p>World Orient Ctrl makes the ik ctrls as joints, so it can make use of the joint orient values. This is for feet that are on the ground.  Because the important thing on feet iks is that they translate in world space. But if they are oriented outwards in the model  (and you are forced to have the blueprints oriented outwards, too), a regular ctrl with a simple transform would not be able to have orientation and translation in different spaces. But the joint has  few extra power with the joint orient values. Look at this gif, it would be impossible to get that behavior from transform joints: </p> <p>Tip</p> <p>If you are using Studio Library, make sure to switch to the latest version. Because older versions don't like joint ctrls. </p> <p>Why is it not just on by default?? Well, it has a disadvantage: when you draw a rectangle to select all the ctrls, it'll only select the joint ctrls and not the others. This is because Maya is trying to help you by making joints a higher selection priority. Unfortunately it's not so helpful in this case. So if animators start whining because of that issue, you'll just have to tell the modelers to make the feet straight so you can switch that option off.</p>"},{"location":"puppet/limbsReference/#pivot-ctrls","title":"Pivot Ctrls","text":"<p>The Pivot Ctrls attribute just defines of which control you want to have as actual ctrls and which ones are just attributes  on the ik ctrl (legIk_l_ctrl). If all animators in the world agreed to one system, we wouldn't need this attribute. But here we are - most animators are very specific about which control they want to rotate and which control they want to slide as attribute. This is what you get when you set it to all:  Switch it to different settings - you'll notice some ctrls disappear, and you have attributes on the ik ctrl (legIk_l_ctrl) instead: </p>"},{"location":"puppet/limbsReference/#toe-fk-ctrl","title":"Toe Fk Ctrl","text":"<p>The Toe Fk Ctrl is the same idea - if it's on, you'll get this ctrl:   If it's off, you'll get toeBend attributes on the IKs (legIk_l_ctrl.toeBend)</p>"},{"location":"puppet/limbsReference/#twist","title":"Twist","text":"<p>The Twist joints get created only if you activate the Advanced:  Watch out for bad flipping! The twist setup is actually very stable and flexible in latest kangaroo version, but only if all the attributes are set properly:  </p> <p>Let's look at Upper Plane and Lower Up Axis first. Those define which should be the stable axes and on which is ok to  flip if it goes into extremes. Upper Plane is for the upper arm. On a biped arm, leave it as default (Y), but for a biped leg or quadruped arm/leg switch it to Z. Lower Up Axis is for the lower limb. On a biped arm, leave it as default (Z), but for a biped leg or quadruped arm/leg switch it to Y.  </p> <p>For the upper arm will still have one more attribute - Arm Twist From PoseT. It should be on for bipeds (default), but should be off for quadrupeds using this limb. What is that doing??  The first part of all the twist math in the upper arm is removing the twist from the upper arm orientation. To remove the twist it has to know in which space the twist should be removed. You might think it should just be the default of the arms. For the legs that would work, but for the arms it would only work if they are in T-Pose. If arms are in A-Pose, the default would have a non-straight pose which is giving issues on certain poses.</p> <p>Warning</p> <p>Do not forget to switch it off for quadruped arms! If you rig a quadruped mouse or bear with this limb and you leave it as default in the arms, the twist will get unstable for sure.</p>"},{"location":"puppet/limbsReference/#bendy-joints","title":"Bendy Joints","text":"<p>Obviously we have bendy joints - activate them on in the Advanced section: </p> <p>Warning</p> <p>If you have a cartoony character, animators will crucify you if you don't add them.</p>"},{"location":"puppet/limbsReference/#squash-stretch-joints","title":"Squash Stretch Joints","text":"<p>This will make the bendy ctrls and knee/elbow stretch ctrls scalable. Makes sure to transfer the weights to the new squash joints!  </p>"},{"location":"puppet/limbsReference/#double-knee","title":"Double Knee","text":"<p>The Double Knee is here to help you for deformations: </p> <p>Tip</p> <p>You'll most likely want it for the knees! For elbows maybe..</p>"},{"location":"puppet/limbsReference/#dogarmleg","title":"DogArmLeg","text":"<p>The DogArmLeg is for any digigrade quadruped such as dogs, cats, .. </p> <p>The tricky thing on the digigrade legs is getting the midfinger roll on the paws behave well.  One thing that helps is getting the fingersMid blueprint joint from the leg placed in the same line as the toes mid joints:   In some cases you might even want to tweak the Dog Mid Finger attributes on the finger limbs: </p> <p>Tip</p> <p>Make sure the model is anatomically correct on the toes! If the anatomy is not correct already in the model, getting a good looking midFinger roll is almost impossible.</p>"},{"location":"puppet/limbsReference/#horsearmleg","title":"HorseArmLeg","text":"<p>Works similar to the DogArmLeg in many ways. But it's simpler to setup because it doesn't need toes:  </p>"},{"location":"puppet/limbsReference/#birdarmleg","title":"BirdArmLeg","text":"<p>Also similar to the DogArmLeg, but it's got the main difference that the first bone is an FK and second and third bones are the IK, while on DogArmLeg the IK is on the first two bones. </p>"},{"location":"puppet/limbsReference/#clavicle-dogscapula","title":"Clavicle, DogScapula","text":""},{"location":"puppet/limbsReference/#auto-clavicle","title":"Auto Clavicle","text":"<p>The Auto Clavicle needs to be activated on the arm limbs:  </p> <p>Warning</p> <p>Make sure you don't have the clavicle/scapula specified in the attachers! In older kangaroo versions you somehow had to - but in latest Kangaroo 5 the next parent should always be the spine. And Kangaroo knows that when  Auto Clavicle is on, the root of the arm will be attached the clavicle/scapula.</p>"},{"location":"puppet/limbsReference/#dogscapula","title":"DogScapula","text":"<p>The DogScapula should be used for most quadrupeds, and in the last Kangaroo versions it has evolved to something far  more complex than the Clavicle. First thing you'll notice on the quadruped template characters it that the scapula blueprints start from the other side and far outside the character:  This is because the clavicle translates in spherical space, outside point is the pivot point of that spherical motion  </p> <p>Note</p> <p>If you are porting from an older version of Kangaroo, please recreate the blueprints. They changed quite a bit.</p> <p>Why is it a spherical motion? Because the scapula translates around the ribcage. And especially for up/down this results in a spherical motion. But not so much for forward/back, that's why you can tune down that a bit with the attributes Horiz Linear Front and Horiz Linear Back.</p> <p>The Pivot On End attribute goes from 0.0 to 1.0 and specifies where the main ctrl should be located. In the following gif the left one is 1.0 and the right one is 0.0:  For most cases you'll want to keep Pivot On End at 1.0, and then let animators use the extra secondary ctrls to do some fine tuning: </p> <p>And for automatically folling the arm, animators have a few options - they can either have it rotate (aim), or they can have it locked in position to the arms.</p> <p>  Especially the autoVert attribute is unavoidable when animators are animating a walk </p> <p>Tip</p> <p>While dogs and cats in real live both rotate and translate their scauplas on the walk, dogs rotate them more than  translate them, and cats translate them more. You might want to set default values accordingly.</p>"},{"location":"puppet/limbsReference/#finger","title":"Finger","text":"<p>The finger is a bit of a special limb. It should only be used with for arms/legs. For any extra special case it's  best to use the spine.</p> <p>Tip</p> <p>If you want to create some more alienated finger setup where you find that the finger limb doesn't help you, you can use the spine limb, make it simply fk and activate Finger Ctrl Names </p>"},{"location":"puppet/limbsReference/#belt","title":"Belt","text":"<p>So many characters have belts, so we created a limb that specificly rigs that. But actually the belt can do more - it can rig anything that's shaped in a circle such as wrist bands, pants cuffs, etc.  The blueprints are very simple. It's just a curve and the ctrl positions are the CVs:   </p> <p>You can specify the ctrl count with the Ctrl Counts attribute, and the joint count with the Curve Joints attribute.  </p>"},{"location":"puppet/limbsReference/#simple-joints","title":"Simple Joints","text":"<p>You can also set Curve Joints to None. In that case it won't put the joints on a spline, and instead will create a joint for each ctrl. And in that case the result is the same as if you would put a few singleTransforms in a circle. We use this very often for simple things such as wrist cuffs or pants cuffs where animators don't need anything fancy, just a few ctrls laid out in a circle.   </p> <p>Note</p> <p>You may have to revisit the blueprints if you switch to no curve joints - since the ctrls are placed at where the  CVs are, the joints will also be on the cvs and NOT on the actual curve!    </p> <p>And something cool - when you create the blueprints for a left and right belt, it still mirrors the layout live! </p>"},{"location":"puppet/limbsReference/#eyes","title":"Eyes","text":"<p>There's Eye, EyesLookat and EyeLookatIndiv.  Those are explained in Eyes.</p>"},{"location":"puppet/limbsReference/#wheel","title":"Wheel","text":"<p>This is for cars</p> <p>New Limb</p> <p>\"wheel\" is new and hasn't been tested in production yet</p>"},{"location":"puppet/limbsReference/#custom-limbs","title":"Custom Limbs","text":"<p>Yes, you can define Custom Limbs. It's rare that we need to do that since the existing ones have a lot of options, and additional features might be easier to handle by just adding additional functions. But if you do want to go into detail and make your own limb, you can find how to do that here</p> <p>Decent Python level required!</p> <p>A decent Python level is required for creating Custom Limbs! Before writing your own custom limb it's recommended to see if you can  solve it with simple Python Functions</p>"},{"location":"puppet/puppetGeneral/","title":"Puppet General","text":"<p>The Puppet tool defines the main ctrls of the character, such as spine logics, arm/leg FK/IK, Auto Clavicle, etc. It generates the blueprints.ma file (guide joints) and the puppet.rig - which then the builder uses to build the rig.</p> <p>Let's look at all the cool elements in the UI: </p> <p>The first table shows the Limbs, and below is the Library. You can just drag a limb from the  library into the Limbs. And whatever limb you have selected, you can adjust the Limb Attributes on the right side</p>"},{"location":"puppet/puppetGeneral/#change-the-guide-joint-locations","title":"Change the Guide Joint Locations","text":"<p>To change the Locations, you need the BP Rig. And to get the BP Rig, click those buttons in the right order: 1. Clean 2. Import BP Skeleton  3. Build BP Rig</p> <p>You'll click these 3 buttons together a million times, here's a gif that shows this process: </p> <p>BP Skeleton is a file with simple joints that tells the builder where the locations are. And the BP Rig is a small rig with ctrls and some logic build on top of the BP Skeleton that helps you place it. </p> <p>Once you have the BP Rig built, place its ctrls: </p> <p>Tip</p> <p>A quick way of importing the model is just clicking the button Import Model.  This runs the importModel() function from the builder. </p> <p>There's a lot of ctrls that can make the placing process very efficient, as long as you move around the ctrls in the right order: </p> <p>The feet might overwhelm you a bit at the first time:  But if you have a character that just has shoes, you might be able to get rid of the toes!  Then it becomes a little simpler: </p> <p>The big ctrl in the middle with the three arrows  is the one  that tells the orientation of the foot. </p> <p>Note</p> <p>If you want to have the feet translate in worldspace (animators usually hate it if they are not), you don't actually have to orient that ctrl to be in worldspace. Check World Orient Ctrl</p> <p>The light red sphere ctrls  are the pivots for things like foot roll and footRocker.  For the sphere on the inside/outside you might be wondering why there's 2 on each side. That's because they also define the orientation. The pivot point is basically in the middle and aiming to one of them.</p> <p>Note</p> <p>On the hands you have the same complexity with all the pivots. Because hands also have the same rocker/roll setup,  except that in most cases it's barely used. </p> <p>When you are done placing the blueprints, click the button Extract+Export Skel. There are 2 very strict rules:</p> <ul> <li>Never export without having built the BP Rig! </li> <li>Never open the previous BP Rig and export from there!</li> </ul> <p>Always follow the 3 button click workflow (Clean -&gt; Import BP Skeleton -&gt; Build BP Rig) from above. It's just to keep things clean.  Any unintentional change resulting from some bad shortcuts can get expensive when we are talking about animation ctrls.</p> <p>Tip</p> <p>You can however move around the joint roots inbetween importing BP Skeleton and building BP Rig.  But ONLY joint roots! If you do want to move around child joints, make sure to only translate them in X. And don't change the sign (postive &lt;-&gt; negative) Moving around joint roots can be useful when placing them for the first time after creation.  </p> <p>Note</p> <p>Theoretically it does let you export without building the BP Rig, but that's not recommended it's only there for debugging purposes. </p>"},{"location":"puppet/puppetGeneral/#adding-limbs","title":"Adding Limbs","text":"<p>You can easily add limbs by dragging one from the libarary table into the limbs table:  </p> <p>And the first thing you do after you created a new limb (and maybe adjusted some attributes) is place the blueprints. If you've already built the BP Rig, you'll have to rebuild it. First import the BP Skeleton. At this point you could build the Blueprint Rig, but often it'll make your life easier if between building Blueprint Skeleton and Blueprint Rig you click Create Missing BP Joints,  and move around just the root (Careful with child joints in this step!). Watch this gif to see how it looks in action: </p> <p>Tip</p> <p>For a full reference of what limbs are there, check the Limbs Reference</p>"},{"location":"puppet/puppetGeneral/#attachers","title":"Attachers","text":"<p>Attachers are all about spaces. For example the Hand IK following the COG or the Spine.  And they need to be fully understood to really use Kangaroo efficiently. Look at how many attachers alone the arm limb has:   And this is not even everything, with attachers you can even make things follow some deformers!    </p> <p>For each of the attachers you can add/remove output points by adjusting the count value: </p> <p>Note</p> <p>Not all attachers have that count value! Especially for the root you'll notice on some that can only one output point.</p>"},{"location":"puppet/puppetGeneral/#translaterotatescale","title":"translate/rotate/scale","text":"<p>You see how every attacher has either (t), (tr), (r) or (s)? Those specify if  translate, rotate or scale is affected.  Whereever you see (tr), you can split it into (t) and (r). In this gif I'm splitting them, and copying from (t) to (r) using the CTRL+C and CTRL+P </p> <p>Tip</p> <p>This is very useful for head or top neck ctrls. Animators always want to control the  position separate to the orientation.</p>"},{"location":"puppet/puppetGeneral/#switch-vs-blend","title":"Switch vs Blend","text":"<p>By default it's just a switch. Animators prefer that in most cases since it's the simplest: </p> <p>Kangaroo Tool Tip</p> <p>There's this tool for animators to switch between the spaces.</p> <p>If you activate the blend checkbox, you'll get an extra attribute for each output point:  Those attributes don't behave the same as constraint weights. Instead it's an additive system being clamped to stay within 0 and 1. Basically from top to bottom they overwrite the previous/upper ones. The first one (in this case parentA) is always 1.0 and locked. If you set parentB to 0.8, parentB has 80 % influence and parentA has 20 %. If then you set parentC to 0.5, parentC has 50 %, parentB has 50 % also, and parentA has 0</p> <p>Tip</p> <p>Animators usually prefer switch because blend seems very technical. But the blend can be very  useful when you setup some special rigs such as props or costumes.  </p>"},{"location":"puppet/puppetGeneral/#custom-attachers","title":"Custom Attachers","text":"<p>Custom Attachers are primarily used to have some ctrls follow the geometry or deformers. Most of the time we make them follow deformers. This looks like the ctrls are following the mesh, but actually they are driven by nodes that replicate the deformer behavior at the vertex closest to the ctrl. To use them, just set the combo box to &lt;Custom&gt; and having the mesh selected, open the Attach Deformer UI: </p> <p>Note</p> <p>Custom attachers are heavily used for Tweaker Ctrls</p> <p>You can also specify a vertex at the bottom. But DO NOT use that unless you have to. Because setting a vertex id means having geometry data inside the puppet data and that gets messy when the mesh topology changes or you want to reuse the setup for another character with different topology: </p>"},{"location":"puppet/puppetGeneral/#display-attributes","title":"Display Attributes","text":""},{"location":"puppet/puppetGeneral/#display_ctrl","title":"display_ctrl","text":"<p>In all the template characters there's the display_ctrl that has a lot of display attributes: </p> <p>And that's just a simple singleTransform limb with its own blueprint:  Don't move it around in the hierarchy in puppet tool! It's important that this is at the top, first limb after the master limb (m_placement in this case)  </p> <p>And all the limbs have display attributes to which tag (attribute) they belong to: </p> <p>Other Ctrls..</p> <p>But what about all the ctrls generated in functions outside of the puppet tool? Usually these functions have an attribute called sDisplayAttr: </p> <p>Tip</p> <p>If you don't like the order of the attributes on the ctrl, those are easily changed on the buildPuppet() function. Just open that attribute in the JSON Editor, and add and/or reorder entries.  </p>"},{"location":"puppet/puppetGeneral/#visibilityattributes","title":"visibilityAttributes()","text":"<p>For any ctrls that are not setup-ed for the displayCtrl, you can use the visibilityAttributes() function.   Just open the JSONEditor on the dData attribute, and add/adjust entries. If the attribute (most left label, master.cuffCtrlVis in this image) doesn't exist, he creates one. So you could even specify one that is created  on the display_ctrl, and just set it up to also switch some geometry visibility.</p>"},{"location":"puppet/puppetGeneral/#python","title":"Python","text":"<p>In the points above we've seen how to just add simple on/off switches. But if you need anything more fancy than that, it's best to solve that with a Python function.</p>"},{"location":"puppet/puppetGeneral/#updating-limbs","title":"Updating limbs","text":"<p>Every limb has versions. The is important because when a limb gets improved, you'll ususally want to keep the  old behavior in existing characters that have already been animated. But if you do want to change the versions, on the right side just switch them:  And if you want to just switch all limbs automatically to the latest one, you can do that with the  button Maximize All Limbs: </p> <p>Don't Forget!</p> <p>Don't forget to click the save button after updating limb versions!</p>"},{"location":"puppet/puppetGeneral/#feature-ctrl-type","title":"Feature Ctrl Type","text":"<p>The Feature Ctrl is a ctrl that holds some of the global arguments for this limb, such as FK2IK Switch or some extra visibiltiy switches. You set it with the attributes called Feature Ctrl Type and CustomFeatureCtrlName.  For the Feature Ctrl Type you have 3 options: Custom Ctrl, New Global Ctrl and Shape on All Ctrls </p>"},{"location":"puppet/puppetGeneral/#custom-ctrl","title":"Custom Ctrl","text":"<p>It's the simplest one, you just specify the name of an already existing ctrl in the Custom Feature Ctrl Name field such as cog_ctrl.  But make sure that in the hierarchy this ctrl is built before the current limb!</p>"},{"location":"puppet/puppetGeneral/#new-global-ctrl","title":"New Global Ctrl","text":"<p>This is probably the one used most of the time. </p>"},{"location":"puppet/puppetGeneral/#shape-on-all-ctrls","title":"Shape on All Ctrls","text":"<p>Animators often ask for the global attributes to be accessible on each ctrl. But in Maya you cannot add one attribute onto more than one ctrl, and the closest thing how to solve this is putting the attributes on a shape node. In Maya you can create one shape node and make it appear on more than one transform (ctrl). </p> <p>Warning</p> <p>Some external tools such as Studio Library don't support this. And writing your own animation tools will likely be more complex  since you always have to check on the ctrls if there's a shape node.</p>"},{"location":"puppet/puppetGeneral/#mirror","title":"Mirror","text":""},{"location":"puppet/puppetGeneral/#mirror-limbs","title":"Mirror Limbs","text":"<p>Mirroring the limbs is easy. Just right click -&gt; mirror from selected. Recursive means that he'll also mirror the children: </p>"},{"location":"puppet/puppetGeneral/#mirror-blueprints","title":"Mirror Blueprints","text":"<p>The blueprints will get mirrored automatically. But if you want to have them unsymmetrical, you can specify that with the triangle ctrl (bpGlobal_ctrl):  </p> <p>For Middle Limbs he'll try to keep the joints in the symmetry axis, unless you tell him not to with the triangle ctrl:  </p>"},{"location":"puppet/puppetGeneral/#nearest-worldspace-matrix","title":"Nearest Worldspace Matrix","text":"<p>Animators often want ctrls to be oriented straight in worldspace.  On some limbs such as Spine and SingleBone you can find a few attributes starting with Orient To Nearest Straight Matrix:  Those will orient the ctrls to be in world space.  </p> <p>Tip</p> <p>Whenever you want some ctrls to be oriented straight, you should always check first if you can solve that with the blueprints. Those Orient To Nearest... attributes should only be used if orienting the blueprints doesn't work well. </p> <p>While most of the time this is easily adjustable with  blueprints, in some places it's more convenient to not rotate them straight.</p>"},{"location":"puppet/puppetGeneral/#joint-parents","title":"Joint Parents","text":"<p>The very first attribute on the top starts with PARENT This doesn't really change the rig logic, but it specifies where the joints should be parented to.  See how those joints would be better parented under one of the lower spine joints? That's what you can fix with  the PARENT attributee: </p>"},{"location":"puppet/tweakerCtrls/","title":"Puppet Tweaker Ctrls","text":""},{"location":"puppet/tweakerCtrls/#what-are-they","title":"What are they?","text":"<p>Tweaker Ctrls are ctrls that follow your current setup, and then deform the mesh with an additional skinCluster. In this example the Cube Ctrl is a tweaker, that follows the previous skinCluster and blendShape setup, but on top of that deforms the mesh with an additional skinCluster.  </p> <p>Info</p> <p>Later in the Face you'll learn about Face Tweaker Ctrls, those are similar logic like this. So if you are planning to set some up for the face, it's recommended to check if those are already taken care in the Face Tweaker Ctrls</p>"},{"location":"puppet/tweakerCtrls/#how-to-set-it-up","title":"How to set it up","text":""},{"location":"puppet/tweakerCtrls/#add-the-limb","title":"Add the limb","text":"<p>This is done with the postRefJoints attribute, the following limbs have it:</p> <ul> <li>singleBone    </li> <li>singleTransform    </li> <li>belt</li> <li>spine (fk, ikSpline, simple)</li> </ul> <p>In the example shown above have the singleTransform limb. It's the simplest, but also the most common one. Make sure to set postRefJoints attribute to True. And the second important thing is setting up the Custom Attachers, so it knows what to follow.</p>"},{"location":"puppet/tweakerCtrls/#custom-attacher","title":"Custom Attacher","text":"<p>First we'll have to setup the Attachers, using the Custom option.   The deformers you select there are crucial. Select all the deformers that the tweaker ctrl should follow. But absolutely do NOT select the skinCluster that the tweaker ctrl will be driving, otherwise you'd get a  cycle.</p> <p>And don't forget the blueprints.</p>"},{"location":"puppet/tweakerCtrls/#skincluster","title":"SkinCluster","text":"<p>After you've built everything - for skinning you need to bind it with an additional skinCluster that has a suffix, in this example we use the TWEAKER skinCluster:   If you don't have an additional skinCluster with a suffix yet, create one by selecting the mesh and clicking the skin shelf button. In that UI make sure you activate Post:   </p>"},{"location":"puppet/tweakerCtrls/#stacking-them","title":"Stacking them","text":"<p>In our example the cheeks are not following anything in the TWEAKER skinCluster. But in many cases you want the Tweaker Ctrl to follow some other Tweaker Ctrls that are already there. To solve that, we stack the tweakers:  First in the custom attacher's Attach DeformerUI you need to specify the other skinCluster that it should follow.   And then create an additional skinCluster that the tweaker ctrl is driving.  </p> <p>Warning</p> <p>It's very easy to run into cycles here. But it's also easy to avoid that, just be aware that the tweaker joints MUST NOT drive any skinCluster that is specified in the attacher. Even just small weights cause a cycle and make the whole rig unstable.</p> <p>Note</p> <p>On some complex characters you might end up with quite a lot of stacked skinClusters: </p> <p>Tip</p> <p>Keep in mind you can always group some tweakers into one skinCluster to keep the number of skinClusters low. You just have to be aware that tweakers inside a skinCluster can't affect each others.</p>"},{"location":"puppet/tweakerCtrls/#spine-tweakers","title":"Spine Tweakers","text":"<p>With the spine you can also do some tweaker fk setup that runs on top of another setup:  It works with the fk. And you have to set the custom attachers on ALL (root, fk_xx), and for the PostRefJoints option you specify ON (all fks have attacher) </p> <p>Note</p> <p>This can also work well on the face for cartoony dog noses. But since you'll have a few more deformers there already, you'll have to be very confident with how to stack them</p>"},{"location":"python/python1/","title":"Python I","text":"<p>As you remember from the builder documentations, everything is written in Python. And we can customize a lot</p>"},{"location":"python/python1/#pycharm","title":"PyCharm","text":"<p>If you have pycharm installed, there's lots of quick ways to jump to a specific code. But for that we have to link it first. On the settings,  </p> <p>And then you can go to any function to the builder and with right click quickly jump to the code. </p> <p>Same thing happens on Errors in the Kangaroo Log - those are links you can just click on  </p>"},{"location":"python/python1/#simple-way-of-adding-a-function","title":"Simple way of adding a Function","text":"<p>The simplest way to add a function is just in the character script. Basically the python file that is  inside your version folder. It's the file that is shown in white, and it's usually the same name ass your asset.</p> <p>In there add a function that looks like this: <pre><code>@builderTools.addToBuild(iOrder=16)\ndef simpleFunction(iLuckyNumber=20, sObjects=[]):\n    print ('Hello, your lucky number is %d' % iLuckyNumber)\n    print ('And the objects are: %s' % sObjects)\n</code></pre></p> <p>And then to get that into the builder, you need to click the  (reload)  button. Basically every time you change any of the scripts, the builder will only know about it if you click that button.  Unless you switch to the character with the upper comboboxes, then he'll reload anyway </p> <p>Remember!</p> <p>Forgetting to click the reload button is a very common thing with kangaroo beginners. So best write it down ;-)</p> <p>Now let's look at the function. The important thing is the decorator that starts with @builderTools.add....  If you don't have that, the function won't show up in the Builder. Do you see the iOrder=16 parameter in the code above? That's the order number where shows up in the  builder. The numbers are listed on the right side of the Function Table. Basically for finding the correct  order number, just look in the table at which place you'd like it to be. If you want the function to run after the LoadDeformer(), the priority attribute needs to be something higher than 50. </p>"},{"location":"python/python1/#function-attributes","title":"Function Attributes","text":"<p>Now let's run the function with the Run Selected button. It should come to no surprise that when you change the attribute in the builder, he'll print the sentence with the new number. </p>"},{"location":"python/python1/#scene-selection","title":"Scene Selection","text":"<p>Getting the scene selection into the attributes is quick. On any attribute that is declared with an empty list, you can do the right click -&gt; Scene Selection option </p>"},{"location":"python/python1/#buttons","title":"Buttons","text":"<p>Let's add a button. Change the above code to this.</p> <p><pre><code>def buttonFunction():\n    print ('a button was clicked')\n\n@builderTools.addToBuild(iOrder=16, dButtons={'new button':buttonFunction})\ndef simpleFunction(iLuckyNumber=20, sObjects=[]):\n    print ('Hello, your lucky number is %d' % iLuckyNumber)\n    print ('And the objects are: %s' % sObjects)\n</code></pre> After clicking the reload button, you'll get this button: </p>"},{"location":"python/python1/#marking-menus","title":"Marking Menus","text":"<p>If you want marking menus into the button, you just nest a few dictionaries:</p> <pre><code>def buttonA():\n    print ('buttonA was clicked')\n\ndef buttonB():\n    print ('buttonB was clicked')\n\ndef buttonC():\n    print ('buttonC was clicked')\n\n@builderTools.addToBuild(iOrder=16, dButtons={'new button':{'buttonA': buttonA, 'more buttons': {'buttonB':buttonB, 'buttonC':buttonC}}})\ndef simpleFunction():\n    pass\n</code></pre> <p>Clicking the reload button with this new code, you'll that that super cool looking marking menu. You can even extract the function with that &lt;--&gt; button, which can be very handy if the menu gets complex.</p> <p></p>"},{"location":"python/python1/#let-the-button-change-your-attributes","title":"Let the Button change your Attributes","text":"<pre><code>def incrementNumber(iLuckyNumber, _uiArgs={}):\n    print ('Lucky number is %d' % iLuckyNumber)\n    iLuckyNumber += 1\n    _uiArgs['iLuckyNumber'].setText(str(iLuckyNumber))\n\n@builderTools.addToBuild(iOrder=16, dButtons={'increment':incrementNumber})\ndef simpleFunction(iLuckyNumber=20):\n    print ('Hello, your lucky number is %d' % iLuckyNumber)\n</code></pre> <p>See how the button changes the attribute's value? This is basically what all those fill buttons in kangaroo are doing: </p>"},{"location":"python/python1/#logging","title":"Logging","text":"<p>While you might be happy enough with the print() function, sometimes it's cool if you can also log into the Kangaroo Log field at the bottom.</p> <p><pre><code>import kangarooTools.report as report\nreport.report.addLogText('Hello World')\n</code></pre> There's just one little catch. You'll have to deselect the function and select it again. Why? Because after he finishes running, the log shows a generalized report how the whole thing did etc. The report.addLogText() is more useful for example after you run've the whole thing and you want to go back to the functions and check their logs. You can imagine it'd be a nightmare if in those cases you would have just used the print() function. </p>"},{"location":"python/python1/#just-buttons","title":"Just Buttons","text":"<p>Sometimes you just want to add a few buttons but no function to run in the builder. <pre><code>def buttonA():\n    print ('buttonA was clicked')\n\n@builderTools.addToBuild(iOrder=16, bNoCheckbox=True, dButtons={'buttonA':buttonA})\ndef simpleFunction():\n    pass\n</code></pre></p> <p>The function then looses its checkbox and gets an italic font. </p>"},{"location":"python/python1/#yellow-lights","title":"Yellow Lights","text":"<p>By default the lights are always green if the function finished running and red when it errored. But sometimes you want to signal to the user that even though it didn't error, it wasn't quite without problems. To do that, simply return False. <pre><code>return False\n</code></pre> And then you get that yellow light: </p>"},{"location":"python/python1/#progress-bar","title":"Progress Bar","text":"<p>Making use of the progressbar at the bottom is easy.  Just run this code: <pre><code>    import kangarooTools.report as report\n    import time\n    iCount = 100\n    report.report.resetProgress(iCount)\n    for i in range(iCount):\n        report.report.incrementProgress()\n        time.sleep(0.03)\n</code></pre></p>"},{"location":"python/python1/#progress-bar-window","title":"Progress Bar Window","text":"<p>You can also have this little window you've probably seen on some other tools.  It involes a bit more code though. And it's best to put some of it into a try block, because otherwise you'll have that annoying window left if your code errors <pre><code>    import kangarooTools.utilsQt as utilsQt\n    import time\n    iCount = 100\n    qStatusWindow = utilsQt.QStatusWindow('Extra Window')\n    try:\n        qStatusWindow.setCount(iCount)\n        for i in range(iCount):\n            qStatusWindow.increment()\n            time.sleep(0.03)\n    except:\n        raise\n    finally:\n        qStatusWindow.end()\n</code></pre></p>"},{"location":"python/python1/#getting-asset-info","title":"Getting Asset Info","text":"<p>Here are some functions for getting the Current Assets <pre><code>import kangarooTools.assets as assets\nassets.getCurrentAsset() # returns the current asset name\nassets.getCurrentProject() # returns the current project name\nassets.getCurrentVersionPath() # returns the absolute version folder inside the *_build* folder\n</code></pre></p>"},{"location":"python/python1/#multiple-instances-of-a-function","title":"Multiple Instances of a Function","text":"<p>One some functions such as the fingerPoses() you can do right click -&gt; set function instant count, and then you'll see the same function more than once:  By default you don't have that option, but you can turn it on with the bCanGetDuplicated flag: <pre><code>@builderTools.addToBuild(iOrder=105, dButtons={}, bCanGetDuplicated=True)\n</code></pre></p>"},{"location":"python/python2/","title":"Python II","text":""},{"location":"python/python2/#running-kangaroo-tools","title":"Running Kangaroo Tools","text":"<p>Many tools in Kangaroo you can run separately in Python. Whenever you click some of the Tool Buttons, check the output log at the bottom: </p>"},{"location":"python/python2/#extra-builds","title":"Extra Builds","text":"<p>In Python I we've learned how to add some fun python stuff to our character file. But what if we want to make a company wide tool that other people can run, too - so everyone can just add the file at the top as shown in this gif:  This is where extrabuilds come in.</p> <p>First we'll have to tell kangaroo with the Environment Variable KANGAROO_EXTRABUILDS_PATH a location where we have other python files with some builds.</p> <p>If you want to do that with the pathEnv.mel file just to get started quickly - the entry would look something like this: <pre><code>putenv \"KANGAROO_EXTRABUILDS_PATH\" \"myBuilds@D:/mayaTools/KANGAROO/myExtraBuilds\";\n</code></pre></p> <p>Btw, for more than one build folder you'd just add them all with the same variable but separated with the ; sign <pre><code>putenv \"KANGAROO_EXTRABUILDS_PATH\" \"myBuildsA@D:/mayaTools/KANGAROO/myExtraBuildsA; myBuildsB@D:/mayaTools/KANGAROO/myExtraBuildsB\";\n</code></pre></p> <p>You could start your new build file by just copying an existing one from the kangarooBuilds folder and rename.</p> <p>Or just start with a simple and clean file, and call it myNewBuild_v0.py:</p> <pre><code>import kangarooTabTools.builder as builderTools\nimport kangarooTools.utilFunctions as utils\n\nkBuilderColor = utils.uiColors.yellow\n\n@builderTools.addToBuild(iOrder=16)\ndef simpleFunction(iLuckyNumber=20, sObjects=[]):\n    print ('Hello, your lucky number is %d' % iLuckyNumber)\n    print ('And the objects are: %s' % sObjects)\n</code></pre> <p>Then you can add it to the builder like shown above.</p>"},{"location":"python/python2/#before-or-after-loaddeformer","title":"Before or After LoadDeformer()","text":"<p>If you are creating a function that generates joints that need to be skinned, you have to be very aware if the function is before loadDeformer() (iPriority smaller than 50) or after (iPriority bigger than 50).  The easiest thing is to add it before. Then at the time it loads the deformer, the joints are there and everybody is happy.  </p> <p>But sometimes it makes sense to put the function after. For those cases, at the time you run the function you have to assume that the joints may or may not already be there,  since loadDeformer() creates an empty joint at the origin if it doesn't exist yet. This means you have to restructure your joint creating code a bit to make it check first if joint is already there or not. This example is from the NLF setup: <pre><code>sJ = 'jnt_%s_nlf_%03d' % (sSide,j)\nif cmds.objExists(sJ):\n    cmds.parent(sJ, jointOrGroup(sParentJoint))\nelse:\n    cmds.createNode('joint', n=sJ, p=jointOrGroup(sParentJoint))\ncmds.setAttr('%s.jo' % sJ, 0,0,0)\n</code></pre></p>"},{"location":"python/python2/#connecting-to-studio-pipeline","title":"Connecting to Studio Pipeline","text":"<p>If you've managed to read until here, you are ready to connect kangaroo to your studio pipeline.</p>"},{"location":"python/python2/#importmodel-replace","title":"importModel() replace","text":"<p>Create a new Extra Builds file as shown in previous chapter, and add a function in there called something like importModel2(). And uncheck the old one (importModel()). In importModel2() create some code that looks in the files of your studio pipeline and imports the correct model. For doing that you'll most likely need the code snippets in Getting Asset Info for getting your current asset infos.</p> <p>Tip</p> <p>For finding the right file, it's best to use the python os module. And once you've cut together the file path with that, you can use the following function to import the file. The importMayaFiles() is good because it  can return the nodes he imported. <pre><code>import kangarooTools.utilFunctions as utils\nutils.importMayaFiles(sFiles, sNamespace=None, bReference=False, bReturnAllNodes=False)\n</code></pre></p>"},{"location":"python/python2/#prepareforpublish-replace","title":"prepareForPublish() replace","text":"<p>Let's look at the function prepareForPublish() in general_v13.py. </p> <pre><code>@builderTools.addToBuild(iOrder=1010)\ndef prepareForPublish(sRenameMaster='master', bDeleteUnrealModel=True):\n    sAsset = assets.assetManager.getCurrentAsset()\n    sUnrealModel = utils.data.get('sUnrealModel', None)\n    if not sUnrealModel:\n        bDeleteUnrealModel = False\n\n    utils.addStringAttr('master', 'sOldMasterName', 'master')\n    sMaster = cmds.rename('master', sRenameMaster)\n    ddMasters = {sMaster:{'sFilename':'RIG_%s_[v].ma' % sAsset,\n                           'sExtraFiles': 'fbx/GAME_%s.fbx' % (sAsset),\n                           'sDelete':['GAMEMODEL'] if bDeleteUnrealModel else []}}\n    utils.data.store('ddMasters', ddMasters, sNode=utils.kExportNode)\n    utils.data.store('bSaveInsteadOfExport', True, sNode=utils.kExportNode)\n</code></pre>"},{"location":"python/python2/#change-file-name-or-delete-nodes","title":"Change File name or Delete Nodes","text":"<p>Focus on the dictionary: <pre><code>ddMasters = {sMaster:{'sFilename':'RIG_%s_[v].ma' % sAsset,\n                       'sExtraFiles': 'fbx/GAME_%s.fbx' % (sAsset),\n                       'sDelete':['GAMEMODEL'] if bDeleteUnrealModel else []}}\n</code></pre> You can see here that you have the power to decide how the filename should look like. And you can specify a few  maya nodes that should get deleted on publish. It's wise not to overuse the deletion thing, and instead add a function that deletes it. But in certain situations the sDelete key can be useful.</p>"},{"location":"python/python2/#copy-output-file-to-a-certain-folder","title":"Copy Output File to a certain Folder","text":"<p>You can also add sCopyToOutputFolder: <pre><code>ddMasters = {'master':{'sFilename':'RIG_%s_[v].ma' % sAsset,\n                       'sCopyOutputToFolder': os.path.join(sParentFolder, '[v]'),\n                       'sExtraFiles': ['fbx/RIG_%s.fbx' % (sAsset), 'fbx/RIGSIMPLE_%s.fbx' % (sAsset)],\n                       'sDelete':['UNREALMODEL'] if bDeleteUnrealModel else []}}\n</code></pre> The [v]*' gets replaced with the version.</p>"},{"location":"python/python2/#run-a-function-after-export","title":"Run a function after export","text":"<p>In some cases the ddMasters keys are not enough. Sometimes in order to put things into the right place, you'll have to add some python code that manipulates the other pipeline, even runs some of their functions. This can be done with: <pre><code>nodes.data.store('sShareFuncPre', 'rig.global.pre_publish', sNode=nodes.kExportNode)\nnodes.data.store('sShareFuncPost', 'rig.global.post_publish', sNode=nodes.kExportNode)\n</code></pre></p> <p>The more useful one is definitely the sShareFuncPost one. You basically pass a function location that gets run after you've published to kangaroo in the usual way. Keep in mind that the function you are passing here (rig.global.post_publish in the example above) needs to be importable in python. So the publish function later will run it as something like: <pre><code>import rig.global\nrig.global.post_publish(sProject, sToAssetFolder, sComments)\n</code></pre></p> <p>Yes, you saw right - it's passing some infos. So the post_publish() function in this example needs to be declared in rig.gobal as  <pre><code>def post_publish(sProject, sToAssetFolder, sComments):\n    print ('sProject: ', sProject)\n    print ('sToAssetFolder: ', sToAssetFolder)\n    print ('sComments: ', sComments)\n</code></pre></p>"},{"location":"python/python2/#custom-limbs","title":"Custom Limbs","text":"<p>Writing your own puppet limbs is where things get very advanced, therefore a decent python level is required. Start by creating an empy folder, and declare it with the Environment Variable KANGAROO_EXTRALIMBS_PATH. Then copy/paste one of the existing limbs from the kangarooLimbs folder of your Kangaroo installation in to that new folder. Simplest one to start with is probably singleTransform.  </p> <p>The attributes that you see in the Puppet tool on the right side are all either just the function parameters of the __init__() function or the feature functions (feature_fk() in this case)</p> <p>The attachers get declared with extra functions: <pre><code>def generateAttachers_init(self):\n    return {'root': {'sTrs':'tr', 'bMulti':False},\n            'scale': {'sTrs':'s', 'bMulti':False}}\n</code></pre> And then inside the feature function you can assign the actual transforms like this: <pre><code>dAttacherBuildData['root'] = (utils.getDagPath(self.cCtrl.sPasser), self.cCtrl)\n</code></pre></p> <p>The actual output joints are defined like this in the __init__() function: <pre><code>self.dOutputs['main'] = None\n</code></pre> Basically in this case you can see that singleTransform limb only has one output. Then on the return, the first one (fks variable in this case) is a list of joints, and needs to be the same length as how many outputs you declared above <pre><code>return fks, cReturnCtrls, dAttacherBuildData\n</code></pre></p>"},{"location":"python/pythonLibrary/","title":"Library","text":"<p>A lot of functions used by Kangaroo tools are very useful. This document shows the most useful ones for whenever you want to add a python function to your asset.</p>"},{"location":"python/pythonLibrary/#utility-nodes","title":"Utility Nodes","text":"<p>The Kangaroo-Builder is using a ton of Maya Utility nodes. If you are creating your own custom scripts, you can use some of the functions that are used inside the Kangaroo-Builder. Those should help you to write your code faster and more readable.</p> <p>Just make sure you import the nodes module <pre><code>import kangarooTools.nodes as nodes\n</code></pre></p> <p>And then you can use all those functions. They all return an output attribute that you can either use in the next function or to connect it with the cmds.connectAttr() function. sTarget is a convenience flag that is in almost all functions. You can keep it as None, or you can add an attribute name. In that case it will automatically connect the output of that function into the that attribute name.</p>"},{"location":"python/pythonLibrary/#multiplydivide-node-1-dimensional","title":"MultiplyDivide Node (1 dimensional)","text":"<pre><code>sMultipl = nodes.createMultiplyNode(xInputA, xInputB, sTarget=None, sOperation='multiply')\ncmds.connectAttr(sMultipl, 'locator1.tx')\n\n# to write it shorter, don't assign it to a variable but set the sTarget flag instead:\nnodes.createMultiplyNode(xInputA, xInputB, sTarget='locator1.tx', sOperation='multiply', sName='noname')\n</code></pre>"},{"location":"python/pythonLibrary/#create-multiplydivide-node-3-dimensional","title":"Create MultiplyDivide Node (3 dimensional)","text":"<p>While most other functions have the bVector flag,  for the multiplyDivide node we have an extra function <pre><code>sMultipl = nodes.createVectorMultiplyNode(xInputA, xInputB, sTarget=None, sOperation='multiply', sName='noname') cmds.connectAttr(sMultipl, 'locator1.tx')\n</code></pre></p>"},{"location":"python/pythonLibrary/#create-plusminusaverage-node-1-dimensional","title":"Create PlusMinusAverage Node (1 dimensional)","text":"<pre><code>nodes.createAdditionNode(xInputs, sTarget=None, sName='noname', sOperation='plus')\n# xInputs is a list of strings and/or numbers. For example ['a.tx', 2, 'b.ty']\n</code></pre>"},{"location":"python/pythonLibrary/#create-plusminusaverage-node-3-dimensional","title":"Create PlusMinusAverage Node (3 dimensional)","text":"<pre><code>nodes.createVectorAdditionNode(xInputs, sTarget=None, sName='noname', sOperation='plus')\n# xInputs is a list of strings and/or vectors. For example ['a.t', [2,0,0], 'b.t']\n</code></pre>"},{"location":"python/pythonLibrary/#create-reversenode","title":"Create ReverseNode","text":"<pre><code>nodes.createReverseNode(xInput, sTarget=None)\n# This is the result of 1-xInput\n</code></pre>"},{"location":"python/pythonLibrary/#create-range-node","title":"Create Range Node","text":"<p>Here instead of having a specific vector node, we use the bOutRangeIsVector. If that\u2019s on, the xOutMin, xOutMax need to be vectors or string attributes that are vectors <pre><code>nodes.createRangeNode(xValue, xInMin, xInMax, xOutMin, xOutMax, sName='noname', sTarget=None, bOutRangeIsVector=False)\n</code></pre></p>"},{"location":"python/pythonLibrary/#create-angle-node","title":"Create Angle Node","text":"<pre><code>nodes.createAngleNode(xInputA, xInputB, sTarget=None, sName='noname')\n</code></pre>"},{"location":"python/pythonLibrary/#create-clamp-node","title":"Create Clamp Node","text":"<pre><code>nodes.createClampNode(xInputA, xMin, xMax, bVector=False, sTarget=None)\n</code></pre>"},{"location":"python/pythonLibrary/#create-distance-node","title":"Create Distance Node","text":"<p><pre><code>nodes.createDistanceNode(xInputA, xInputB, sTarget=None, sName='noname', fNormalized=None, sDivide=None)\n</code></pre> if you set fNormalized to 1.0, it makes sure that the output is 1.0 on the current pose. sDivide can be used to divide the output by the global scale</p>"},{"location":"python/pythonLibrary/#create-condition-node","title":"Create Condition Node","text":"<pre><code>nodes.createConditionNode(xFirstTerm, sOperator, xSecondTerm, xOutputTrue, xOutputFalse, sName='noname', sFullName=None, bVector=False, sTarget=None, bForce=False)\n# sOperator can be '==', '&lt;', '&lt;=', '&gt;=' or '!='\n</code></pre>"},{"location":"python/pythonLibrary/#string-expression-to-nodes","title":"String Expression to Nodes","text":"<p>There's a function that takes a spring expression and puts that into nodes. <pre><code>sExpr = nodes.fromEquation('(3 + node.out) * 0.5')\n</code></pre></p> <p>Looks fancy - but we've ended up using the utility node functions above more. There's only one place in the armLeg limb, where we use it on a more complex function: <pre><code>sExpr = '%s * (1.0 - (%0.8f ^ ((%s - %s) / %s))) + %s' % (sSoftAttr, math.e, sSoftAttrRev, sDistanceNormalized, sSoftAttrSafe, sSoftAttrRev)\nsSoftExpr = nodes.fromEquation(sExpr, sFullName=self._createNodeName('softIk'))\n</code></pre></p>"},{"location":"python/pythonLibrary/#driven-keys","title":"Driven Keys","text":""},{"location":"python/pythonLibrary/#direct","title":"direct","text":"<pre><code>nodes.setDrivenKey(sDriverAttr, fDriverVals, sDrivenAttrPath, fDrivenVals, sInTanType='clamped', sOutTanType='clamped')\n# fDriverVals is a list of driver values, and fDrivenVals is a list of driven values\n\n# In this example below if locator1.ty is 2, locator2.ty will be 10\nnodes.setDrivenKey('locator1.ty', [0,1,2], 'locator2.ty', [5,2,10]) \n</code></pre>"},{"location":"python/pythonLibrary/#indirect","title":"indirect","text":"<p>Sometimes when the driver values on the sDriverAttr are a result of a specific pose of a control, it\u2019s more convenient to set the values by the control. In this function we also have sDriverAttr, however no fDriverVals. Those are created under the hood from the sCtrlAttr and fCtrlValues flags. <pre><code>nodes.setDrivenKeyController(sCtrlAttr, fCtrlValues, sDriverAttr, sDrivenAttr, fDrivenVals, sInTanType='linear', sOutTanType='linear', sFullName=None)\n</code></pre></p>"},{"location":"python/pythonLibrary/#curves","title":"Curves","text":"<p>Import the following functions like this: <pre><code>import kangarooTools.curves as curves\n</code></pre></p>"},{"location":"python/pythonLibrary/#create-pointoncurveinfo-node","title":"Create pointOnCurveInfo node","text":"<pre><code>sNode, sPoint = curves.createPointInfoNode(sBeltCurve, fParam=0.5)\n</code></pre> <p>That node needs the parameter. To quickly convert between parameter, positions and percentages chech the following chapter.</p>"},{"location":"python/pythonLibrary/#getting-curves-values","title":"Getting Curves Values","text":"<p>There's a ton of functions that convert between points, params and percs with functions. They are easy to find since they all have the same naming convention.</p> <p>Here some examples: <pre><code>#  Getting points from the joint Percentages:\nfPointsOnCurve = curves.getPointsFromPercs(sCurve, [0, 0.2, 0.5, 0.8, 1.0], bReturnNumpy=True)\n\n# Getting points from the joint Percentages:\nfPointsOnCurve = curves.getParamsFromPercs(sCurve, [0, 0.2, 0.5, 0.8, 1.0], bReturnNumpy=True)\n\n# Getting percentages from Params:\naPercs = curves.getPercsFromParams(sCtrlBpCurves[0], [0, 0.5, 1.4])\n</code></pre></p>"},{"location":"python/pythonLibrary/#joints-to-ctrls-weighting","title":"Joints to Ctrls Weighting","text":"<p>The getCtrlWeightings2() function takes joint params (or percentages) and ctrl params (or percentages) and gives you back a list with the length of the joints.</p> <p>For each joint something like [2, 3, 0.25]. In this example it means the weighing for this joint is between ctrl 2  and ctrl 3, with the ratio of 0.25 (0.0 would mean fully at ctrl 2, and 1.0 would mean fully at ctrl 3)</p> <pre><code>xCtrlWeightings = xforms.getCtrlWeightings2(fJointParams, fCtrlParams, fIsCircleWithParamLength=None)\n</code></pre>"},{"location":"python/pythonLibrary/#create-deformers","title":"Create Deformers","text":"<p>Since the loadDeformer() handles mainly weights, in some cases it's cleaner to create the deformers in python before the loadDeformer() function. <pre><code>import kangarooTools.deformers as deformers\n</code></pre></p>"},{"location":"python/pythonLibrary/#create-morph","title":"Create Morph","text":"<p>For blending a mesh to another, use the morph <pre><code>deformers.createMorph(sChild, sParent)\n</code></pre></p>"},{"location":"python/pythonLibrary/#legacy-wrap-deformer","title":"Legacy Wrap Deformer","text":"<pre><code>sUnorderedWraps, sBase = deformers.createWrap(sChildren, sParent, bExclusiveBind=True)\n</code></pre>"},{"location":"python/pythonLibrary/#proximity-wrap-deformer","title":"Proximity Wrap Deformer","text":"<pre><code>deformers.createProximityWrap(sChild, sDrivers, sName=None, bCreateBaseMesh=False, fFalloffScale=10.0)\n</code></pre>"},{"location":"python/pythonLibrary/#add-blendshape-targets","title":"Add blendShape Targets","text":"<pre><code>import kangarooTools.blendShapes as blendShapes\nsTargetAttrs = blendShapes.addTargets(sMesh, sTargetMeshes)\n</code></pre>"},{"location":"tools/toolsDeformerImport/","title":"Deformer Import","text":"<p>With the Deformer Import tool you can do the same thing as what the loadDeformer() function does but with a few more options.</p> <p></p> <p>The purpose of this tool is to fix some deformers if:  </p> <ul> <li>models changed, or</li> <li>you like the weights on a certain part of the mesh more in a previous version</li> </ul> <p>Only SkinClusters</p> <p>This does only the standard skinClusters. It will not work on other deformers such as deltamush or post skinClusters with suffixes.</p>"},{"location":"tools/toolsDeformerImport/#when-to-not-use-it","title":"When to NOT use it","text":""},{"location":"tools/toolsDeformerImport/#simple-mesh-changes","title":"Simple Mesh Changes","text":"<p>When the mesh names changed, very often you can just rename the .wts files inside the deformers folder.  They all have the same naming convention (TYPE__MESHNAME.wts or TYPE__MESHNAME__SUFFIX.wts).   </p> <p>Those file names basically consist of 2 or 3 parts, separated by double underscores (__). And the second part is the mesh name. So for example if the mesh got changed from body_geo to torso_geo, the file deltaMush__body_geo__MOUTH.npz needs to be changed to deltaMush__torso_geo__MOUTH.npz </p> <p>Watch Out for Underscores!</p> <p>Don't confuse the double underscore (__) with the single underscore (_). They might look the same at first glance, but  mixing them up can lead to very bad troubles.</p>"},{"location":"tools/toolsDeformerImport/#simple-topology-changes","title":"Simple Topology Changes","text":"<p>If the topolgoy changed, and you have set the bWorldSpaceIfNotMatching attribute set to True in the  loadDeformer() function, it'll load things automatically by worldspace. This works because all the .wts files contain information about the mesh.</p> <p>Tip</p> <p>You can also leave this attribute at True. It'll only do worldSpace transfer if the topology changed.  In older Kangaroo versions it was inconvenient to leave it as True, because it was easy to overlook the model change. But in the latest version on some situations (like the newScene() function or puppet clean button) it'll remind you  that it transferred the weights by asking you if you want to save the weights.</p>"},{"location":"tools/toolsDeformerImport/#load","title":"Load","text":"<p>For whatever meshes you have selected it'll search for the files and loads them. Sounds simple but the real power is that it supports vertex (soft) selection.   </p> <p>So you could select vertices across different meshes: </p> <p>Maybe even switch to an older version where you liked the weights more (note how it turns orange - that just indicates you are not on latest version): </p> <p>And click the Load button.</p>"},{"location":"tools/toolsDeformerImport/#load-best-fitting-skinclusters","title":"Load best fitting skinClusters","text":"<p>This button is great for when your character has many meshes, and modellers decided to just blindly rename a lot of meshes.</p>"},{"location":"tools/toolsGeometry/","title":"Geometry","text":""},{"location":"tools/toolsGeometry/#mirror","title":"Mirror","text":"<p>Video</p> <p>The Mirror is shown in the first part of the Video</p> <p>While the video already gives you a good intro in how to use them, here's a few extra features that got added after creating the video:</p> <p>Mirror Middle now has the checkbox Matrix on Base that mirrors the vertices local to the vertex matrices.  This gives better results when mirroring poses where the basemesh is unsymmetrical.</p> <p>On MirrorMiddle additionally to Closest Vertex you now also have Closest Point, which is useful when the  topology of your mesh is unsymmetrical</p>"},{"location":"tools/toolsGeometry/#create-symmetry-mesh","title":"Create Symmetry Mesh","text":"<p>Video</p> <p>Creating symmetry mesh is explained here</p>"},{"location":"tools/toolsGeometry/#match-vertex-positions","title":"Match Vertex Positions","text":"<p>Very simple but extremely seful tool to just match some vertices to another mesh.</p> <p>Video</p> <p>See it in action here</p>"},{"location":"tools/toolsGeometry/#warp-poses","title":"Warp Poses","text":"<p>This is for when we have a model change and you have some sculpted poses.</p> <p>If you are using Shape Editor or Pose Editor, the warping is tied into there. But if you have meshes outside of those tools, you can use this tool to warp them.</p> <p>Video</p> <p>See how it works in this video (Model Change). For the options, the video recommends matrix, but lately is has shown that most of the time Wrap Deformer  is the best option, even if topology is the same. The first part of this video is outdated!. We now use the Pose Editor instead of those python functions.</p>"},{"location":"tools/toolsGeometry/#warp-secondary-poses","title":"Warp Secondary Poses","text":"<p>This is for warping poses to secondary meshes</p> <p>If you are using Shape Editor or Pose Editor, the warping is tied into there. But if you have meshes outside of those tools, you can use this tool to warp them.</p> <p>Video</p> <p>See how it works in this video.  The first part of this video is outdated!. We now use the Pose Editor instead of those python functions.</p>"},{"location":"tools/toolsGeometry/#head-reset","title":"Head Reset","text":"<p>This is usually for modelers, it's to reorder the vertices so all the head ones start from 0. This has the advantage that facial blendShapes can be sculpted on a smaller mesh that doesn't include the body.</p> <p>Select the head faces, and click Head Reset selected Faces. This will create 2 new meshes: One with suffix _HEAD1, and one with suffix _NEWTOPOLOGY. It does NOT change the original mesh! So you'll have to delete the original mesh and replace it with the _NEWTOPOLOGY one. The _HEAD one is the one that you can use for creating blendShapes.</p>"},{"location":"tools/toolsGeometry/#smooth-vertices","title":"Smooth Vertices","text":"<p>This relaxes the vertices. It's similar to the smooth sculpting tool, but works just on vertex (soft) selection. It's very useful for when sculpting Correctives and you want to relax some faces that are collapsed from a pose.</p>"},{"location":"tools/toolsGeometry/#curve","title":"Curve","text":"<p>Here you can slide or move perpendicular some vertices along a curve. It can be useful for sculpting some expressions  on a very curved mouth</p>"},{"location":"tools/toolsGeometry/#warp-xforms","title":"Warp XForms","text":"<p>This warps xforms between 2 meshes.  You have an option to do blueprint ctrls for the Blueprint Rig. So you can use that tool if the proportions changed but topology is the same, or if you are setting up a new character that has same topology but different proportions.</p> <p>Video</p> <p>There's a short video on LinkedIn that demonstrates it: LinkedIn Post on warpXForms</p>"},{"location":"tools/toolsPlaneCutter/","title":"Plane Cutter","text":""},{"location":"tools/toolsPlaneCutter/#plane-cutter","title":"Plane Cutter","text":"<p>Plane Skinner is a tool that can get you quick first pass SkinCluster or Proxy Geometries</p>"},{"location":"tools/toolsSkinCluster/","title":"SkinCluster","text":"<p>Kangaroo's Skinning Tools are an alternative to weight painting. The idea is that you always select vertices with soft selection, and then click the buttons. This usually keeps the weights cleaner than if you were using painting tools.  </p> <p> </p> <p>The best way to learn about the skinning tools is by watching this video. Use this page more as a table of contents. You'll see a lot of direct links to the proper time stamps of that video.</p>"},{"location":"tools/toolsSkinCluster/#choose-skincluster","title":"Choose SkinCluster","text":"<p>The skinning tools work for multiple skinClusters, and the attribute to specify which one is Choose SkinCluster.  If you leave it empty, it chooses the default one. </p> <p>Video</p> <p>Check here to see in action how Choose SkinCluster works.</p> <p>Note</p> <p>One thing that got added after the video was created is that you can also specify suffixes in the Choose SkinCluster field, such as __BEND or __ZIPPER. This makes it easier when you have more meshes all with same skinClusters suffixes.</p>"},{"location":"tools/toolsSkinCluster/#flood","title":"Flood","text":"<p>It's similar to what the Maya Flood button is doing, but here you have more options:  </p> <ul> <li>Select more than one influence at the same time. It assigns the weights by closest joints to each vertex, and smoothes on top (you can control the smoothness with the Smooth Steps </li> <li>You can do more than one influences at the same time</li> <li>You can flood joints that are not in the skinCluster yet, he'll ask you if they should be added</li> </ul> <p>Video</p> <p>Flood is the first thing shown in the Video</p> <p>One thing not fully explained in the video is Joint Lines. Joint Lines are ... </p>"},{"location":"tools/toolsSkinCluster/#distribute","title":"Distribute","text":"<p>Distribute Weights is an option inside the Flood tool. This gets overlooked a lot, but it's one of those powerful  features that make Kangaroo Skinning Tools special!  It first gathers all the weights assigned to the selected joints, and then reassigns the weights based  on closest joints to each vertex. This is useful for:  </p> <ul> <li>when you changed the joint positions</li> <li>if you've bound them with normal Flood settings, but with bad Smooth Steps</li> </ul> <p>Tip</p> <p>Most of the time when using the Distribute options we can just select the whole mesh. Because he won't touch the vertices that didn't have weights from the selected joints.</p> <p>Video</p> <p>Check Distribute Option here</p>"},{"location":"tools/toolsSkinCluster/#closestexpand","title":"ClosestExpand","text":"<p>Closest Expand tool is for situations such as lips or eyelids, where you have joint splines and each joint is located on a vertex. It basically finds the closest vertices for each joint, and then expands the influence. How much you expand is defined with the Expanded Full Weight Loops and Expanded Fade Out Loops.</p> <p>The tool also works for high density meshes where you are skipping joints, for example you only have a joint for each second or third vertex. If you are skipping many joints, keep an eye on the Max Connection Path Count option.  </p>"},{"location":"tools/toolsSkinCluster/#distribute_1","title":"Distribute","text":"<p>The ClosestExpand tool also comes with a Distribute attribute. The idea is the same as with the one in the Flood tool - it first gathers all the weights that are already on the joints, and uses that as a mask for the new operation.  Make sure to set Full Weight Loops to a higher value such as 30, because the fade out amount is already handled through  the previous weights. This is useful when you've already generated the weights and then you did changes to the setup.  </p> <p>Video</p> <p>Check here to see ClosestExpand in action  </p>"},{"location":"tools/toolsSkinCluster/#smooth","title":"Smooth","text":"<p>Well - what can I say, the properly most popular tool in the set. But don't overuse it!!</p> <p>Video</p> <p>Check Smooth Tool here</p>"},{"location":"tools/toolsSkinCluster/#average","title":"Average","text":"<p>This averages the weights. Often you use it on buttons. It can also average islands separately, which is  for example when you have a lot of buttons combined into a single mesh.  </p> <p>Video</p> <p>Check Average Tool here</p>"},{"location":"tools/toolsSkinCluster/#transfer","title":"Transfer","text":"<p>Transfers weights from another mesh. Make sure you try using it together with Vertex (Soft) Selection! But there's also a lot of other imporant hidden features, best watch the video from the link below:</p> <p>Video</p> <p>Check Average Tool here</p>"},{"location":"tools/toolsSkinCluster/#inttransfer","title":"IntTransfer","text":"<p>Like Transfer, but transfers from within the same mesh. To use that properly, just select a few vertices without Soft Selection. Because the algorithm will for each selected vertex find the the closest non-selected vertex and transfer from that.   </p> <p>Video</p> <p>Check here to see IntTransfer in action  </p>"},{"location":"tools/toolsSkinCluster/#copypaste","title":"Copy/Paste","text":"<p>Select a vertex to copy from, and click Copy, then select vertices you want to paste to, and click Paste. On the Paste you can also do Soft Selection, and also you can paste onto a different mesh. It'll just ask you if he should assign the new influences.</p> <p>Video</p> <p>Check here to see copy/paste in action.   </p>"},{"location":"tools/toolsSkinCluster/#mirrortopo","title":"MirrorTopo","text":"<p>This is using the Edgeflow Algorithm where he takes an edge in the middle, and searches through the whole mesh to find which vertex belongs to which. It works on meshes that have different shape left and right, as long as the topology is symmetrical. By Topology we refer to the way how edges are connected together.</p> <p>Video</p> <p>Check here for better explanation.   </p>"},{"location":"tools/toolsSkinCluster/#mirror","title":"Mirror","text":"<p>For all cases where we don't have Symmetrical Topology, we use the standard Mirror tool. This also works with multiple meshes selected, and he can mirror from left to right meshes.</p> <p>Mirror Middle is the second button in that tool - it just averages left/right, best apply it just to vertices close to the symmetry line.</p> <p>Video</p> <p>Check here to see it in action.   Just the Mirror Middle is a new button and therefore not shown in the video.</p>"},{"location":"tools/toolsSkinCluster/#move","title":"Move","text":"<p>Moves weights between joints.  You specify joints in the tab. Weights from joints in the left column get assigned to the joints in the right column. Sounds simple, right? Well, it also has a ton of hidden options:  </p> <ul> <li>You can move weights from one or more than one joints to one or more than one joints.  </li> <li>The left column in the tab can have * and ? in the name.</li> <li>For the right ones - if you add a comma (\",\"), he does text replacing (left part of the comma with right part) example: \"^, namespace0:\" will find the To joints in the namespace \"namespace0:\"</li> <li>You can also add joints to the columns by right click Set From Selected</li> </ul> <p>Video</p> <p>Check here to see it in action.    </p> <p>Tip</p> <p>This is also a great tool to use in Python for creating your own tools.</p> <pre><code>import kangarooTabTools.weights as weights\nweights.moveSkinClusterWeights(sMesh, xJoints={'jnt_m_faceZero':'jnt_m_zero'})\n</code></pre>"},{"location":"tools/toolsSkinCluster/#prune","title":"Prune","text":"<p>Similar to the Maya prune, but first assigns stuff into weight islands. This means you can prune with a higher value without getting weight artefacts.</p> <p>Video</p> <p>Check here for better explanation.  Actually to get the full picture it's best starting from  Why can I not paint Weights Kangaroo Skin Tools?.</p>"},{"location":"tools/toolsSkinCluster/#maxinf","title":"MaxInf","text":"<p>This makes sure that each vertex has not more than a specific amount of influences. Very important when you are rigging for Game Engines. Only works on full meshes (no vertex selection)</p> <p>Video</p> <p>Check here to see it in action.   </p>"},{"location":"tools/toolsSkinCluster/#normalize","title":"Normalize","text":"<p>Nothing fancy, just does what the maya normalize does, except that you can choose a specific skinCluster Only works on full meshes (no vertex selection)</p>"},{"location":"tools/toolsSkinCluster/#python","title":"Python","text":"<p>You can also run those tools in python</p> <p>Video</p> <p>Check how to run those tools in python here</p>"},{"location":"tools/toolsWeightmaps/","title":"Weightmaps","text":"<p>Weightmap tools are for adjusting weightmaps from deformers such as lattice, morph, deltamesh, ... basically almost all deformers apart from skinCluster.</p> <p> </p> <p>The best thing to learn about the weightmap tools is by watching the Video </p> <p>Weightmap have similar features as skinCluster tools. They can do:  </p> <ul> <li>Flood (first section of the Video)</li> <li>Smooth/Average (Video)</li> <li>Transfer (Video)</li> <li>Mirror (Video)</li> </ul>"}]}